{"id": "2601.10953", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2601.10953", "abs": "https://arxiv.org/abs/2601.10953", "authors": ["Junming Zhang", "Qinyan Zhang", "Huajun Sun", "Feiyang Gao", "Sheng Hu", "Rui Nie", "Xiangshui Miao"], "title": "SwiftKV: An Edge-Oriented Attention Algorithm and Multi-Head Accelerator for Fast, Efficient LLM Decoding", "comment": null, "summary": "Edge acceleration for large language models is crucial for their widespread application; however, achieving fast attention inference and efficient decoding on resource-constrained edge accelerators remains challenging. This paper presents SwiftKV Attention, a per-token pipelined, low-latency single-pass attention inference algorithm, where every (kt, vt) in the KV cache is processed exactly once in a uniform per-token pipeline without score materialization, blockwise softmax, or a second pass, thereby enabling fast execution on edge accelerators with a single hardware set and no resource-intensive parallelism. Furthermore, to address the limited support for multi-head LLM decoding in existing accelerators, we design the SwiftKV-MHA accelerator, which enables high precision attention and low precision GEMV on the same processor array, achieving fast and efficient multi-head parallel decoding. Experimental results show that, on the edge accelerator, the SwiftKV Attention algorithm achieves a 7.16* speedup over native attention and significantly outperforms other attention algorithms. SwiftKV-MHA further reduces attention latency by 13.48*; under the same settings, it improves generation speed by 17.4% and increases token efficiency by 1.98* compared with state-of-the-art works.", "AI": {"tldr": "SwiftKV Attention\uff1a\u4e00\u79cd\u9488\u5bf9\u8fb9\u7f18\u52a0\u901f\u5668\u7684\u5355\u901a\u9053\u6ce8\u610f\u529b\u63a8\u7406\u7b97\u6cd5\uff0c\u65e0\u9700\u5206\u6570\u7269\u5316\u6216\u4e8c\u6b21\u5904\u7406\uff0c\u5b9e\u73b07.16\u500d\u52a0\u901f\u3002SwiftKV-MHA\u52a0\u901f\u5668\u652f\u6301\u591a\u5934\u5e76\u884c\u89e3\u7801\uff0c\u8fdb\u4e00\u6b65\u964d\u4f4e\u5ef6\u8fdf13.48\u500d\u3002", "motivation": "\u5927\u578b\u8bed\u8a00\u6a21\u578b\u5728\u8fb9\u7f18\u8bbe\u5907\u4e0a\u7684\u52a0\u901f\u81f3\u5173\u91cd\u8981\uff0c\u4f46\u5728\u8d44\u6e90\u53d7\u9650\u7684\u8fb9\u7f18\u52a0\u901f\u5668\u4e0a\u5b9e\u73b0\u5feb\u901f\u6ce8\u610f\u529b\u63a8\u7406\u548c\u9ad8\u6548\u89e3\u7801\u4ecd\u7136\u5177\u6709\u6311\u6218\u6027\u3002\u73b0\u6709\u65b9\u6cd5\u5b58\u5728\u8ba1\u7b97\u5197\u4f59\u548c\u786c\u4ef6\u652f\u6301\u4e0d\u8db3\u7684\u95ee\u9898\u3002", "method": "\u63d0\u51faSwiftKV Attention\u7b97\u6cd5\uff1a\u57fa\u4e8e\u6bcf\u4ee4\u724c\u6d41\u6c34\u7ebf\u7684\u5355\u901a\u9053\u6ce8\u610f\u529b\u63a8\u7406\uff0c\u6bcf\u4e2a(k_t, v_t)\u5728KV\u7f13\u5b58\u4e2d\u4ec5\u5904\u7406\u4e00\u6b21\uff0c\u65e0\u9700\u5206\u6570\u7269\u5316\u3001\u5206\u5757softmax\u6216\u4e8c\u6b21\u5904\u7406\u3002\u8bbe\u8ba1SwiftKV-MHA\u52a0\u901f\u5668\uff0c\u5728\u540c\u4e00\u5904\u7406\u5668\u9635\u5217\u4e0a\u5b9e\u73b0\u9ad8\u7cbe\u5ea6\u6ce8\u610f\u529b\u548c\u4f4e\u7cbe\u5ea6GEMV\uff0c\u652f\u6301\u591a\u5934\u5e76\u884c\u89e3\u7801\u3002", "result": "\u5728\u8fb9\u7f18\u52a0\u901f\u5668\u4e0a\uff0cSwiftKV Attention\u76f8\u6bd4\u539f\u751f\u6ce8\u610f\u529b\u5b9e\u73b07.16\u500d\u52a0\u901f\uff0c\u663e\u8457\u4f18\u4e8e\u5176\u4ed6\u6ce8\u610f\u529b\u7b97\u6cd5\u3002SwiftKV-MHA\u8fdb\u4e00\u6b65\u964d\u4f4e\u6ce8\u610f\u529b\u5ef6\u8fdf13.48\u500d\uff0c\u5728\u76f8\u540c\u8bbe\u7f6e\u4e0b\u76f8\u6bd4\u6700\u5148\u8fdb\u5de5\u4f5c\u63d0\u9ad8\u751f\u6210\u901f\u5ea617.4%\uff0c\u63d0\u5347\u4ee4\u724c\u6548\u73871.98\u500d\u3002", "conclusion": "SwiftKV Attention\u7b97\u6cd5\u548cSwiftKV-MHA\u52a0\u901f\u5668\u6709\u6548\u89e3\u51b3\u4e86\u8fb9\u7f18\u8bbe\u5907\u4e0aLLM\u63a8\u7406\u7684\u6311\u6218\uff0c\u901a\u8fc7\u521b\u65b0\u7684\u5355\u901a\u9053\u5904\u7406\u67b6\u6784\u548c\u786c\u4ef6\u8bbe\u8ba1\uff0c\u5b9e\u73b0\u4e86\u663e\u8457\u7684\u6027\u80fd\u63d0\u5347\u548c\u6548\u7387\u6539\u8fdb\u3002"}}
{"id": "2601.11057", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2601.11057", "abs": "https://arxiv.org/abs/2601.11057", "authors": ["Hongshi Tan", "Yao Chen", "Xinyu Chen", "Qizhen Zhang", "Cheng Chen", "Weng-Fai Wong", "Bingsheng He"], "title": "RidgeWalker: Perfectly Pipelined Graph Random Walks on FPGAs", "comment": "Accepted by HPCA 2026", "summary": "Graph Random Walks (GRWs) offer efficient approximations of key graph properties and have been widely adopted in many applications. However, GRW workloads are notoriously difficult to accelerate due to their strong data dependencies, irregular memory access patterns, and imbalanced execution behavior. While recent work explores FPGA-based accelerators for GRWs, existing solutions fall far short of hardware potential due to inefficient pipelining and static scheduling. This paper presents RidgeWalker, a high-performance GRW accelerator designed for datacenter FPGAs. The key insight behind RidgeWalker is that the Markov property of GRWs allows decomposition into stateless, fine-grained tasks that can be executed out-of-order without compromising correctness. Building on this, RidgeWalker introduces an asynchronous pipeline architecture with a feedback-driven scheduler grounded in queuing theory, enabling perfect pipelining and adaptive load balancing. We prototype RidgeWalker on datacenter FPGAs and evaluated it across a range of GRW algorithms and real-world graph datasets. Experimental results demonstrate that RidgeWalker achieves an average speedup of 7.0x over state-of-the-art FPGA solutions and 8.1x over GPU solutions, with peak speedups of up to 71.0x and 22.9x, respectively. The source code is publicly available at https://github.com/Xtra-Computing/RidgeWalker.", "AI": {"tldr": "RidgeWalker\u662f\u4e00\u4e2a\u57fa\u4e8eFPGA\u7684\u9ad8\u6027\u80fd\u56fe\u968f\u673a\u6e38\u8d70\u52a0\u901f\u5668\uff0c\u901a\u8fc7\u9a6c\u5c14\u53ef\u592b\u6027\u8d28\u5206\u89e3\u4efb\u52a1\u548c\u5f02\u6b65\u6d41\u6c34\u7ebf\u67b6\u6784\uff0c\u5b9e\u73b0\u4e867.0\u500d\u4e8e\u73b0\u6709FPGA\u65b9\u6848\u548c8.1\u500d\u4e8eGPU\u65b9\u6848\u7684\u52a0\u901f\u6548\u679c\u3002", "motivation": "\u56fe\u968f\u673a\u6e38\u8d70\uff08GRW\uff09\u5728\u4f17\u591a\u5e94\u7528\u4e2d\u7528\u4e8e\u8fd1\u4f3c\u56fe\u5c5e\u6027\uff0c\u4f46\u7531\u4e8e\u5176\u5f3a\u6570\u636e\u4f9d\u8d56\u6027\u3001\u4e0d\u89c4\u5219\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\u548c\u8d1f\u8f7d\u4e0d\u5747\u8861\u7b49\u95ee\u9898\uff0c\u4f20\u7edf\u52a0\u901f\u65b9\u6cd5\u96be\u4ee5\u5145\u5206\u53d1\u6325\u786c\u4ef6\u6f5c\u529b\uff0c\u73b0\u6709FPGA\u65b9\u6848\u56e0\u4f4e\u6548\u6d41\u6c34\u7ebf\u548c\u9759\u6001\u8c03\u5ea6\u800c\u8868\u73b0\u4e0d\u4f73\u3002", "method": "\u57fa\u4e8eGRW\u7684\u9a6c\u5c14\u53ef\u592b\u6027\u8d28\uff0c\u5c06\u4efb\u52a1\u5206\u89e3\u4e3a\u65e0\u72b6\u6001\u7684\u7ec6\u7c92\u5ea6\u4efb\u52a1\uff0c\u652f\u6301\u4e71\u5e8f\u6267\u884c\u800c\u4e0d\u5f71\u54cd\u6b63\u786e\u6027\u3002\u8bbe\u8ba1\u4e86\u5f02\u6b65\u6d41\u6c34\u7ebf\u67b6\u6784\uff0c\u91c7\u7528\u57fa\u4e8e\u6392\u961f\u7406\u8bba\u7684\u53cd\u9988\u9a71\u52a8\u8c03\u5ea6\u5668\uff0c\u5b9e\u73b0\u5b8c\u7f8e\u6d41\u6c34\u5316\u548c\u81ea\u9002\u5e94\u8d1f\u8f7d\u5747\u8861\u3002", "result": "\u5728\u6570\u636e\u4e2d\u5fc3FPGA\u4e0a\u539f\u578b\u5b9e\u73b0\uff0c\u5b9e\u9a8c\u663e\u793a\u5e73\u5747\u6bd4\u6700\u5148\u8fdbFPGA\u65b9\u6848\u5feb7.0\u500d\uff0c\u6bd4GPU\u65b9\u6848\u5feb8.1\u500d\uff0c\u5cf0\u503c\u52a0\u901f\u5206\u522b\u8fbe\u523071.0\u500d\u548c22.9\u500d\u3002", "conclusion": "RidgeWalker\u901a\u8fc7\u521b\u65b0\u7684\u4efb\u52a1\u5206\u89e3\u548c\u81ea\u9002\u5e94\u8c03\u5ea6\u67b6\u6784\uff0c\u663e\u8457\u63d0\u5347\u4e86\u56fe\u968f\u673a\u6e38\u8d70\u7684\u8ba1\u7b97\u6548\u7387\uff0c\u4e3a\u6570\u636e\u4e2d\u5fc3FPGA\u4e0a\u7684\u56fe\u8ba1\u7b97\u52a0\u901f\u63d0\u4f9b\u4e86\u6709\u6548\u89e3\u51b3\u65b9\u6848\u3002"}}
{"id": "2601.11292", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2601.11292", "abs": "https://arxiv.org/abs/2601.11292", "authors": ["Yiqi Zhou", "JunHao Ma", "Xingyang Li", "Yule Sheng", "Yue Yuan", "Yikai Wang", "Bochang Wang", "Yiheng Wu", "Shan Shen", "Wei Xing", "Daying Sun", "Li Li", "Zhiqiang Xiao"], "title": "OpenACM: An Open-Source SRAM-Based Approximate CiM Compiler", "comment": "Accepted by DATE 2026", "summary": "The rise of data-intensive AI workloads has exacerbated the ``memory wall'' bottleneck. Digital Compute-in-Memory (DCiM) using SRAM offers a scalable solution, but its vast design space makes manual design impractical, creating a need for automated compilers. A key opportunity lies in approximate computing, which leverages the error tolerance of AI applications for significant energy savings. However, existing DCiM compilers focus on exact arithmetic, failing to exploit this optimization. This paper introduces OpenACM, the first open-source, accuracy-aware compiler for SRAM-based approximate DCiM architectures. OpenACM bridges the gap between application error tolerance and hardware automation. Its key contribution is an integrated library of accuracy-configurable multipliers (exact, tunable approximate, and logarithmic), enabling designers to make fine-grained accuracy-energy trade-offs. The compiler automates the generation of the DCiM architecture, integrating a transistor-level customizable SRAM macro with variation-aware characterization into a complete, open-source physical design flow based on OpenROAD and the FreePDK45 library. This ensures full reproducibility and accessibility, removing dependencies on proprietary tools. Experimental results on representative convolutional neural networks (CNNs) demonstrate that OpenACM achieves energy savings of up to 64\\% with negligible loss in application accuracy. The framework is available on \\href{https://github.com/ShenShan123/OpenACM}{OpenACM:URL}", "AI": {"tldr": "OpenACM\u662f\u9996\u4e2a\u5f00\u6e90\u3001\u7cbe\u5ea6\u611f\u77e5\u7684SRAM\u8fd1\u4f3c\u8ba1\u7b97\u5185\u5b58\u7f16\u8bd1\u5668\uff0c\u901a\u8fc7\u96c6\u6210\u53ef\u914d\u7f6e\u7cbe\u5ea6\u4e58\u6cd5\u5668\u5e93\uff0c\u5728\u4fdd\u8bc1AI\u5e94\u7528\u7cbe\u5ea6\u7684\u540c\u65f6\u5b9e\u73b0\u9ad8\u8fbe64%\u7684\u80fd\u8017\u8282\u7701\u3002", "motivation": "\u6570\u636e\u5bc6\u96c6\u578bAI\u5de5\u4f5c\u8d1f\u8f7d\u52a0\u5267\u4e86\"\u5185\u5b58\u5899\"\u74f6\u9888\uff0c\u6570\u5b57\u8ba1\u7b97\u5185\u5b58(DCiM)\u867d\u63d0\u4f9b\u53ef\u6269\u5c55\u89e3\u51b3\u65b9\u6848\uff0c\u4f46\u5176\u5e9e\u5927\u8bbe\u8ba1\u7a7a\u95f4\u4f7f\u624b\u52a8\u8bbe\u8ba1\u4e0d\u5207\u5b9e\u9645\u3002\u73b0\u6709DCiM\u7f16\u8bd1\u5668\u4e13\u6ce8\u4e8e\u7cbe\u786e\u8ba1\u7b97\uff0c\u672a\u80fd\u5229\u7528AI\u5e94\u7528\u7684\u8bef\u5dee\u5bb9\u5fcd\u7279\u6027\u8fdb\u884c\u80fd\u8017\u4f18\u5316\u3002", "method": "\u5f00\u53d1OpenACM\u7f16\u8bd1\u5668\uff0c\u96c6\u6210\u7cbe\u5ea6\u53ef\u914d\u7f6e\u4e58\u6cd5\u5668\u5e93\uff08\u7cbe\u786e\u3001\u53ef\u8c03\u8fd1\u4f3c\u548c\u5bf9\u6570\uff09\uff0c\u81ea\u52a8\u5316\u751f\u6210DCiM\u67b6\u6784\uff0c\u5c06\u6676\u4f53\u7ba1\u7ea7\u53ef\u5b9a\u5236SRAM\u5b8f\u4e0e\u53d8\u5f02\u611f\u77e5\u7279\u6027\u96c6\u6210\u5230\u57fa\u4e8eOpenROAD\u548cFreePDK45\u7684\u5f00\u6e90\u7269\u7406\u8bbe\u8ba1\u6d41\u7a0b\u4e2d\u3002", "result": "\u5728\u4ee3\u8868\u6027\u5377\u79ef\u795e\u7ecf\u7f51\u7edc\u4e0a\u7684\u5b9e\u9a8c\u8868\u660e\uff0cOpenACM\u5728\u4fdd\u6301\u5e94\u7528\u7cbe\u5ea6\u635f\u5931\u53ef\u5ffd\u7565\u7684\u60c5\u51b5\u4e0b\uff0c\u5b9e\u73b0\u4e86\u9ad8\u8fbe64%\u7684\u80fd\u8017\u8282\u7701\u3002\u8be5\u6846\u67b6\u5b8c\u5168\u5f00\u6e90\uff0c\u786e\u4fdd\u53ef\u91cd\u73b0\u6027\u548c\u53ef\u8bbf\u95ee\u6027\u3002", "conclusion": "OpenACM\u586b\u8865\u4e86\u5e94\u7528\u8bef\u5dee\u5bb9\u5fcd\u4e0e\u786c\u4ef6\u81ea\u52a8\u5316\u4e4b\u95f4\u7684\u7a7a\u767d\uff0c\u4e3aSRAM\u8fd1\u4f3cDCiM\u67b6\u6784\u63d0\u4f9b\u4e86\u9996\u4e2a\u5f00\u6e90\u3001\u7cbe\u5ea6\u611f\u77e5\u7684\u7f16\u8bd1\u5668\u89e3\u51b3\u65b9\u6848\uff0c\u5b9e\u73b0\u4e86\u7ec6\u7c92\u5ea6\u7cbe\u5ea6-\u80fd\u8017\u6743\u8861\u3002"}}
