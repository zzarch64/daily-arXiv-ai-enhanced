{"id": "2602.15166", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2602.15166", "abs": "https://arxiv.org/abs/2602.15166", "authors": ["Tanner Andrulis", "Michael Gilbert", "Vivienne Sze", "Joel S. Emer"], "title": "Fast and Fusiest: An Optimal Fusion-Aware Mapper for Accelerator Modeling and Evaluation", "comment": null, "summary": "The latency and energy of tensor algebra accelerators depend on how data movement and operations are scheduled (i.e., mapped) onto accelerators, so determining the potential of an accelerator architecture requires both a performance model and a mapper to search for the optimal mapping. A key optimization that the mapper must explore is fusion, meaning holding data on-chip between computation steps, which has been shown to reduce energy and latency by reducing DRAM accesses. However, prior mappers cannot find optimal mappings with fusion (i.e., fused mappings) in a feasible runtime because the number of fused mappings to search increases exponentially with the number of workload computation steps.\n  In this paper, we introduce the Fast and Fusiest Mapper (FFM), the first mapper to quickly find optimal mappings in a comprehensive fused mapspace for tensor algebra workloads. FFM shrinks the search space by pruning subsets of mappings (i.e., partial mappings) that are shown to never be a part of optimal mappings, quickly eliminating all suboptimal mappings with those partial mappings as subsets. Then FFM joins partial mappings to construct optimal fused mappings. We evaluate FFM and show that, although the mapspace size grows exponentially with the number of computation steps, FFM's runtime scales approximately linearly. FFM is orders of magnitude faster ($>1000\\times$) than prior state-of-the-art approaches at finding optimal mappings for Transformers.", "AI": {"tldr": "FFM\u662f\u9996\u4e2a\u80fd\u5feb\u901f\u5728\u5f20\u91cf\u4ee3\u6570\u5de5\u4f5c\u8d1f\u8f7d\u7684\u878d\u5408\u6620\u5c04\u7a7a\u95f4\u4e2d\u5bfb\u627e\u6700\u4f18\u6620\u5c04\u7684\u6620\u5c04\u5668\uff0c\u901a\u8fc7\u526a\u679d\u548c\u90e8\u5206\u6620\u5c04\u7ec4\u5408\u89e3\u51b3\u878d\u5408\u6620\u5c04\u641c\u7d22\u7684\u6307\u6570\u7ea7\u590d\u6742\u5ea6\u95ee\u9898\u3002", "motivation": "\u73b0\u6709\u6620\u5c04\u5668\u65e0\u6cd5\u5728\u53ef\u884c\u65f6\u95f4\u5185\u627e\u5230\u878d\u5408\u6620\u5c04\u7684\u6700\u4f18\u89e3\uff0c\u56e0\u4e3a\u878d\u5408\u6620\u5c04\u7684\u641c\u7d22\u7a7a\u95f4\u968f\u8ba1\u7b97\u6b65\u9aa4\u6570\u91cf\u5448\u6307\u6570\u589e\u957f\uff0c\u9650\u5236\u4e86\u5f20\u91cf\u4ee3\u6570\u52a0\u901f\u5668\u7684\u6027\u80fd\u6f5c\u529b\u8bc4\u4f30\u3002", "method": "FFM\u901a\u8fc7\u526a\u679d\u6c38\u8fdc\u4e0d\u4f1a\u6210\u4e3a\u6700\u4f18\u6620\u5c04\u7684\u90e8\u5206\u6620\u5c04\u5b50\u96c6\u6765\u7f29\u5c0f\u641c\u7d22\u7a7a\u95f4\uff0c\u7136\u540e\u901a\u8fc7\u8fde\u63a5\u90e8\u5206\u6620\u5c04\u6765\u6784\u5efa\u6700\u4f18\u878d\u5408\u6620\u5c04\uff0c\u5b9e\u73b0\u8fd1\u4f3c\u7ebf\u6027\u7684\u8fd0\u884c\u65f6\u6269\u5c55\u3002", "result": "FFM\u5728Transformer\u7b49\u4efb\u52a1\u4e2d\u5bfb\u627e\u6700\u4f18\u6620\u5c04\u7684\u901f\u5ea6\u6bd4\u73b0\u6709\u6700\u4f18\u65b9\u6cd5\u5feb1000\u500d\u4ee5\u4e0a\uff0c\u4e14\u5c3d\u7ba1\u6620\u5c04\u7a7a\u95f4\u5927\u5c0f\u5448\u6307\u6570\u589e\u957f\uff0cFFM\u7684\u8fd0\u884c\u65f6\u5374\u8fd1\u4f3c\u7ebf\u6027\u6269\u5c55\u3002", "conclusion": "FFM\u9996\u6b21\u5b9e\u73b0\u4e86\u5728\u878d\u5408\u6620\u5c04\u7a7a\u95f4\u4e2d\u5feb\u901f\u5bfb\u627e\u6700\u4f18\u6620\u5c04\uff0c\u89e3\u51b3\u4e86\u5f20\u91cf\u4ee3\u6570\u52a0\u901f\u5668\u6620\u5c04\u641c\u7d22\u7684\u5173\u952e\u74f6\u9888\uff0c\u4e3a\u52a0\u901f\u5668\u67b6\u6784\u8bc4\u4f30\u63d0\u4f9b\u4e86\u9ad8\u6548\u5de5\u5177\u3002"}}
{"id": "2602.15172", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2602.15172", "abs": "https://arxiv.org/abs/2602.15172", "authors": ["Michael Gilbert", "Tanner Andrulis", "Vivienne Sze", "Joel S. Emer"], "title": "The Turbo-Charged Mapper: Fast and Optimal Mapping for Accelerator Modeling and Evaluation", "comment": null, "summary": "The energy and latency of an accelerator running a deep neural network (DNN) depend on how the computation and data movement are scheduled in the accelerator (i.e., mapping). Optimizing mappings is essential to evaluating and designing accelerators. However, the space of mappings is large, and prior works can not guarantee finding optimal mappings because they use heuristics or metaheuristics to narrow down the space. These limitations preclude proper hardware evaluation, since designers can not tell whether performance differences are due to changes in hardware or suboptimal mapping.\n  To address this challenge, we propose the Turbo-Charged Mapper (TCM), a fast mapper that is guaranteed to find optimal mappings. The key to our approach is that we define a new concept in mapping, called dataplacement, which, like the prior concept of dataflow, allows for clear analysis and comparison of mappings. Through it, we identify multiple opportunities to prune redundant and suboptimal mappings, reducing search space by up to 32 orders of magnitude.\n  Leveraging these insights, TCM can perform full mapspace searches, making it the first mapper that can find optimal mappings in feasible runtime. Compared to prior mappers, we show that TCM can find optimal mappings quickly (less than a minute), while prior works can not find optimal mappings (energy-delay-product $21\\%$ higher than optimal) even when given $1000\\times$ the runtime ($>10$ hours).", "AI": {"tldr": "TCM\u662f\u4e00\u4e2a\u4fdd\u8bc1\u627e\u5230\u6700\u4f18\u6620\u5c04\u7684\u5feb\u901f\u6620\u5c04\u5668\uff0c\u901a\u8fc7\u5b9a\u4e49\u6570\u636e\u653e\u7f6e\u6982\u5ff5\u548c\u526a\u679d\u7b56\u7565\uff0c\u5c06\u641c\u7d22\u7a7a\u95f4\u51cf\u5c1132\u4e2a\u6570\u91cf\u7ea7\uff0c\u80fd\u57281\u5206\u949f\u5185\u627e\u5230\u6700\u4f18\u6620\u5c04\uff0c\u800c\u73b0\u6709\u65b9\u6cd5\u5373\u4f7f\u8fd0\u884c10\u5c0f\u65f6\u4e5f\u65e0\u6cd5\u627e\u5230\u6700\u4f18\u89e3\u3002", "motivation": "\u73b0\u6709\u52a0\u901f\u5668\u6620\u5c04\u4f18\u5316\u65b9\u6cd5\u4f7f\u7528\u542f\u53d1\u5f0f\u6216\u5143\u542f\u53d1\u5f0f\u7b97\u6cd5\uff0c\u65e0\u6cd5\u4fdd\u8bc1\u627e\u5230\u6700\u4f18\u6620\u5c04\uff0c\u8fd9\u963b\u788d\u4e86\u786c\u4ef6\u8bc4\u4f30\u7684\u51c6\u786e\u6027\uff0c\u56e0\u4e3a\u65e0\u6cd5\u533a\u5206\u6027\u80fd\u5dee\u5f02\u662f\u6e90\u4e8e\u786c\u4ef6\u6539\u8fdb\u8fd8\u662f\u6b21\u4f18\u6620\u5c04\u3002", "method": "\u63d0\u51faTurbo-Charged Mapper (TCM)\uff0c\u5b9a\u4e49\u65b0\u7684\u6570\u636e\u653e\u7f6e\u6982\u5ff5\uff0c\u4e0e\u6570\u636e\u6d41\u6982\u5ff5\u7ed3\u5408\uff0c\u8bc6\u522b\u5e76\u526a\u679d\u5197\u4f59\u548c\u6b21\u4f18\u6620\u5c04\uff0c\u5c06\u641c\u7d22\u7a7a\u95f4\u51cf\u5c11\u9ad8\u8fbe32\u4e2a\u6570\u91cf\u7ea7\u3002", "result": "TCM\u80fd\u57281\u5206\u949f\u5185\u627e\u5230\u6700\u4f18\u6620\u5c04\uff0c\u800c\u73b0\u6709\u65b9\u6cd5\u5373\u4f7f\u8fd0\u884c10\u5c0f\u65f6\uff081000\u500d\u65f6\u95f4\uff09\u4e5f\u65e0\u6cd5\u627e\u5230\u6700\u4f18\u89e3\uff0c\u5176\u80fd\u91cf\u5ef6\u8fdf\u4e58\u79ef\u6bd4\u6700\u4f18\u89e3\u9ad821%\u3002", "conclusion": "TCM\u662f\u9996\u4e2a\u80fd\u5728\u53ef\u884c\u65f6\u95f4\u5185\u8fdb\u884c\u5b8c\u6574\u6620\u5c04\u7a7a\u95f4\u641c\u7d22\u5e76\u4fdd\u8bc1\u627e\u5230\u6700\u4f18\u6620\u5c04\u7684\u6620\u5c04\u5668\uff0c\u4e3a\u51c6\u786e\u7684\u786c\u4ef6\u8bc4\u4f30\u548c\u8bbe\u8ba1\u63d0\u4f9b\u4e86\u5173\u952e\u5de5\u5177\u3002"}}
{"id": "2602.15336", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2602.15336", "abs": "https://arxiv.org/abs/2602.15336", "authors": ["Yogeswar Reddy Thota", "Setareh Rafatirad", "Homayoun Houman", "Tooraj Nikoubin"], "title": "Human-AI Interaction: Evaluating LLM Reasoning on Digital Logic Circuit included Graph Problems, in terms of creativity in design and analysis", "comment": null, "summary": "Large Language Models (LLMs) are increasingly used by undergraduate students as on-demand tutors, yet their reliability on circuit- and diagram-based digital logic problems remains unclear. We present a human- AI study evaluating three widely used LLMs (GPT, Gemini, and Claude) on 10 undergraduate-level digital logic questions spanning non-standard counters, JK-based state transitions, timing diagrams, frequency division, and finite-state machines. Twenty-four students performed pairwise model comparisons, providing per-question judgments on (i) preferred model, (ii) perceived correctness, (iii) consistency, (iv) verbosity, and (v) confidence, along with global ratings of overall model quality, satisfaction across multiple dimensions (e.g., accuracy and clarity), and perceived mental effort required to verify answers. To benchmark technical validity, we applied an independent judge-based evaluation against official solutions for all ten questions, using strict correctness criteria. Results reveal a consistent gap between perceived helpfulness and formal correctness: for the most sequentially demanding problems (Q1- Q7), none of the evaluated LLMs matched the official answers, despite producing confident, well-structured explanations that students often rated favorably. Error analysis indicates that models frequently default to canonical textbook templates (e.g., standard ripple counters) and struggle to translate circuit structure into exact state evolution and timing behavior. These findings suggest that, without verification scaffolds, LLMs may be unreliable for core digital logic topics and can inadvertently reinforce misconceptions in undergraduate instruction.", "AI": {"tldr": "\u8bc4\u4f30GPT\u3001Gemini\u548cClaude\u5728\u6570\u5b57\u903b\u8f91\u95ee\u9898\u4e0a\u7684\u8868\u73b0\uff0c\u53d1\u73b0\u6a21\u578b\u5728\u6280\u672f\u6b63\u786e\u6027\u4e0a\u5b58\u5728\u4e25\u91cd\u7f3a\u9677\uff0c\u4f46\u5b66\u751f\u5374\u5e38\u8ba4\u4e3a\u5176\u56de\u7b54\u6709\u5e2e\u52a9\uff0c\u63ed\u793a\u4e86\u611f\u77e5\u6709\u7528\u6027\u4e0e\u5b9e\u9645\u6b63\u786e\u6027\u4e4b\u95f4\u7684\u5dee\u8ddd\u3002", "motivation": "\u968f\u7740LLMs\u8d8a\u6765\u8d8a\u591a\u5730\u88ab\u672c\u79d1\u751f\u7528\u4f5c\u6309\u9700\u5bfc\u5e08\uff0c\u9700\u8981\u8bc4\u4f30\u5b83\u4eec\u5728\u7535\u8def\u548c\u56fe\u8868\u76f8\u5173\u7684\u6570\u5b57\u903b\u8f91\u95ee\u9898\u4e0a\u7684\u53ef\u9760\u6027\uff0c\u56e0\u4e3a\u8fd9\u4e9b\u9886\u57df\u5bf9\u51c6\u786e\u6027\u8981\u6c42\u9ad8\uff0c\u9519\u8bef\u53ef\u80fd\u5f3a\u5316\u5b66\u751f\u7684\u8bef\u89e3\u3002", "method": "\u91c7\u7528\u4eba\u673a\u4ea4\u4e92\u7814\u7a76\uff0c\u8ba924\u540d\u5b66\u751f\u6bd4\u8f83\u4e09\u79cd\u4e3b\u6d41LLM\uff08GPT\u3001Gemini\u3001Claude\uff09\u572810\u4e2a\u672c\u79d1\u6570\u5b57\u903b\u8f91\u95ee\u9898\u4e0a\u7684\u8868\u73b0\uff0c\u540c\u65f6\u8fdb\u884c\u72ec\u7acb\u7684\u6cd5\u5b98\u8bc4\u4f30\uff0c\u4f7f\u7528\u4e25\u683c\u6b63\u786e\u6027\u6807\u51c6\u5bf9\u6bd4\u5b98\u65b9\u7b54\u6848\u3002", "result": "\u5bf9\u4e8e\u6700\u590d\u6742\u7684\u65f6\u5e8f\u95ee\u9898\uff08Q1-Q7\uff09\uff0c\u6240\u6709\u6a21\u578b\u90fd\u65e0\u6cd5\u5339\u914d\u5b98\u65b9\u7b54\u6848\uff0c\u5c3d\u7ba1\u5b83\u4eec\u751f\u6210\u4e86\u81ea\u4fe1\u3001\u7ed3\u6784\u826f\u597d\u7684\u89e3\u91ca\uff0c\u5b66\u751f\u5e38\u7ed9\u4e88\u79ef\u6781\u8bc4\u4ef7\u3002\u6a21\u578b\u503e\u5411\u4e8e\u4f7f\u7528\u6807\u51c6\u6559\u79d1\u4e66\u6a21\u677f\uff0c\u96be\u4ee5\u51c6\u786e\u8f6c\u6362\u7535\u8def\u7ed3\u6784\u4e3a\u72b6\u6001\u6f14\u5316\u548c\u65f6\u5e8f\u884c\u4e3a\u3002", "conclusion": "\u5728\u6ca1\u6709\u9a8c\u8bc1\u6846\u67b6\u7684\u60c5\u51b5\u4e0b\uff0cLLMs\u5728\u6838\u5fc3\u6570\u5b57\u903b\u8f91\u4e3b\u9898\u4e0a\u53ef\u80fd\u4e0d\u53ef\u9760\uff0c\u53ef\u80fd\u65e0\u610f\u4e2d\u5f3a\u5316\u672c\u79d1\u6559\u5b66\u4e2d\u7684\u8bef\u89e3\uff0c\u9700\u8981\u5f00\u53d1\u9a8c\u8bc1\u5de5\u5177\u6765\u786e\u4fdd\u6559\u80b2\u5e94\u7528\u4e2d\u7684\u53ef\u9760\u6027\u3002"}}
{"id": "2602.15388", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2602.15388", "abs": "https://arxiv.org/abs/2602.15388", "authors": ["Yonghao Wang", "Jiaxin Zhou", "Yang Yin", "Hongqin Lyu", "Zhiteng Chao", "Wenchao Ding", "Jing Ye", "Tiancheng Wang", "Huawei Li"], "title": "Iterative LLM-Based Assertion Generation Using Syntax-Semantic Representations for Functional Coverage-Guided Verification", "comment": "6 pages, 6 figures", "summary": "While leveraging LLMs to automatically generate SystemVerilog assertions (SVAs) from natural language specifications holds great potential, existing techniques face a key challenge: LLMs often lack sufficient understanding of IC design, leading to poor assertion quality in a single pass. Therefore, verifying whether the generated assertions effectively cover the functional specifications and designing feedback mechanisms based on this coverage remain significant hurdles. To address these limitations, this paper introduces CoverAssert, a novel iterative framework for optimizing SVA generation with LLMs. The core contribution is a lightweight mechanism for matching generated assertions with specific functional descriptions in the specifications. CoverAssert achieves this by clustering the joint representations of semantic features of LLM-generated assertions and structural features extracted from abstract syntax trees (ASTs) about signals related to assertions, and then mapping them back to the specifications to analyze functional coverage quality. Leveraging this capability, CoverAssert constructs a feedback loop based on functional coverage to guide LLMs in prioritizing uncovered functional points, thereby iteratively improving assertion quality. Experimental evaluations on four open-source designs demonstrate that integrating CoverAssert with state-of-the-art generators, AssertLLM and Spec2Assertion, achieves average improvements of 9.57 % in branch coverage, 9.64 % in statement coverage, and 15.69 % in toggle coverage.", "AI": {"tldr": "CoverAssert\u662f\u4e00\u4e2a\u57fa\u4e8eLLM\u7684\u8fed\u4ee3\u6846\u67b6\uff0c\u901a\u8fc7\u529f\u80fd\u8986\u76d6\u7387\u53cd\u9988\u5faa\u73af\u4f18\u5316SystemVerilog\u65ad\u8a00\u751f\u6210\uff0c\u663e\u8457\u63d0\u5347\u8986\u76d6\u7387\u6307\u6807\u3002", "motivation": "\u73b0\u6709LLM\u751f\u6210SystemVerilog\u65ad\u8a00\u7684\u6280\u672f\u9762\u4e34\u5173\u952e\u6311\u6218\uff1aLLM\u5bf9IC\u8bbe\u8ba1\u7406\u89e3\u4e0d\u8db3\u5bfc\u81f4\u5355\u6b21\u751f\u6210\u7684\u65ad\u8a00\u8d28\u91cf\u5dee\uff0c\u4e14\u7f3a\u4e4f\u6709\u6548\u7684\u529f\u80fd\u8986\u76d6\u7387\u9a8c\u8bc1\u548c\u53cd\u9988\u673a\u5236\u3002", "method": "\u63d0\u51faCoverAssert\u6846\u67b6\uff0c\u901a\u8fc7\u805a\u7c7bLLM\u751f\u6210\u65ad\u8a00\u7684\u8bed\u4e49\u7279\u5f81\u548cAST\u63d0\u53d6\u7684\u7ed3\u6784\u7279\u5f81\uff0c\u5c06\u5176\u6620\u5c04\u56de\u89c4\u683c\u8bf4\u660e\u4ee5\u5206\u6790\u529f\u80fd\u8986\u76d6\u7387\u8d28\u91cf\uff0c\u5e76\u57fa\u4e8e\u8986\u76d6\u7387\u6784\u5efa\u53cd\u9988\u5faa\u73af\u6307\u5bfcLLM\u4f18\u5148\u5904\u7406\u672a\u8986\u76d6\u7684\u529f\u80fd\u70b9\u3002", "result": "\u5728\u56db\u4e2a\u5f00\u6e90\u8bbe\u8ba1\u4e0a\u7684\u5b9e\u9a8c\u8868\u660e\uff0cCoverAssert\u4e0e\u6700\u5148\u8fdb\u7684\u751f\u6210\u5668AssertLLM\u548cSpec2Assertion\u96c6\u6210\u540e\uff0c\u5e73\u5747\u5206\u652f\u8986\u76d6\u7387\u63d0\u53479.57%\uff0c\u8bed\u53e5\u8986\u76d6\u7387\u63d0\u53479.64%\uff0c\u7ffb\u8f6c\u8986\u76d6\u7387\u63d0\u534715.69%\u3002", "conclusion": "CoverAssert\u901a\u8fc7\u8f7b\u91cf\u7ea7\u7684\u65ad\u8a00-\u89c4\u683c\u5339\u914d\u673a\u5236\u548c\u57fa\u4e8e\u529f\u80fd\u8986\u76d6\u7387\u7684\u53cd\u9988\u5faa\u73af\uff0c\u6709\u6548\u89e3\u51b3\u4e86LLM\u751f\u6210SystemVerilog\u65ad\u8a00\u7684\u8d28\u91cf\u95ee\u9898\uff0c\u663e\u8457\u63d0\u5347\u4e86\u65ad\u8a00\u8986\u76d6\u7387\u3002"}}
