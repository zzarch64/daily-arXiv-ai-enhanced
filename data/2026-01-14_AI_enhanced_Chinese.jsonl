{"id": "2601.08368", "categories": ["cs.AR", "cs.CR"], "pdf": "https://arxiv.org/pdf/2601.08368", "abs": "https://arxiv.org/abs/2601.08368", "authors": ["Marie Bolzer", "S\u00e9bastien Duval", "Marine Minier"], "title": "A New Tool to Find Lightweight (And, Xor) Implementations of Quadratic Vectorial Boolean Functions up to Dimension 9", "comment": null, "summary": "The problem of finding a minimal circuit to implement a given function is one of the oldest in electronics. It is known to be NP-hard. Still, many tools exist to find sub-optimal circuits to implement a function. In electronics, such tools are known as synthesisers. However, these synthesisers aim to implement very large functions (a whole electronic chip). In cryptography, the focus is on small functions, hence the necessity for new dedicated tools for small functions. Several tools exist to implement small functions. They differ by their algorithmic approach (some are based on Depth-First-Search as introduced by Ullrich in 2011, some are based on SAT-solvers like the tool desgined by Stoffelen in 2016, some non-generic tools use subfield decomposition) and by their optimisation criteria (some optimise for circuit size, others for circuit depth, and some for side-channel-protected implementations). However, these tools are limited to functions operating on less than 5 bits, sometimes 6 bits for quadratic functions, or to very simple functions. The limitation lies in a high computing time. We propose a new tool (The tool is provided alongside the IEEE article with CodeOcean and at https://github.com/seduval/implem-quad-sbox) to implement quadratic functions up to 9 bits within AND-depth 1, minimising the number of AND gates. This tool is more time-efficient than previous ones, allowing to explore larger implementations than others on 6 bits or less and allows to reach larger sizes, up to 9 bits.", "AI": {"tldr": "\u63d0\u51fa\u65b0\u5de5\u5177\u5b9e\u73b09\u4f4d\u4e8c\u6b21\u51fd\u6570\u5728AND-depth 1\u4e0b\u7684\u6700\u5c0fAND\u95e8\u6570\u7535\u8def\uff0c\u76f8\u6bd4\u73b0\u6709\u5de5\u5177\u66f4\u9ad8\u6548", "motivation": "\u73b0\u6709\u7535\u8def\u7efc\u5408\u5de5\u5177\u4e3b\u8981\u9488\u5bf9\u5927\u89c4\u6a21\u7535\u5b50\u82af\u7247\u8bbe\u8ba1\uff0c\u800c\u5bc6\u7801\u5b66\u9700\u8981\u9488\u5bf9\u5c0f\u51fd\u6570\u7684\u4e13\u7528\u5de5\u5177\u3002\u73b0\u6709\u5c0f\u51fd\u6570\u5de5\u5177\u9650\u4e8e5-6\u4f4d\uff0c\u8ba1\u7b97\u65f6\u95f4\u957f", "method": "\u5f00\u53d1\u65b0\u5de5\u5177\uff08\u63d0\u4f9bCodeOcean\u548cGitHub\u4ee3\u7801\uff09\uff0c\u4e13\u95e8\u9488\u5bf9\u4e8c\u6b21\u51fd\u6570\uff0c\u5728AND-depth 1\u7ea6\u675f\u4e0b\u6700\u5c0f\u5316AND\u95e8\u6570\u91cf", "result": "\u5de5\u5177\u80fd\u5904\u74069\u4f4d\u4e8c\u6b21\u51fd\u6570\uff0c\u6bd4\u73b0\u6709\u5de5\u5177\u66f4\u9ad8\u6548\uff0c\u57286\u4f4d\u4ee5\u4e0b\u80fd\u63a2\u7d22\u66f4\u5927\u5b9e\u73b0\u7a7a\u95f4\uff0c\u9996\u6b21\u8fbe\u52309\u4f4d\u89c4\u6a21", "conclusion": "\u65b0\u5de5\u5177\u586b\u8865\u4e86\u5c0f\u51fd\u6570\u7535\u8def\u7efc\u5408\u7684\u7a7a\u767d\uff0c\u7279\u522b\u9002\u7528\u4e8e\u5bc6\u7801\u5b66\u5e94\u7528\uff0c\u80fd\u9ad8\u6548\u5b9e\u73b09\u4f4d\u4e8c\u6b21\u51fd\u6570\u7684\u6700\u5c0fAND\u95e8\u7535\u8def"}}
