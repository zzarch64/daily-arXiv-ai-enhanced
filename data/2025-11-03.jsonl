{"id": "2510.26944", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2510.26944", "abs": "https://arxiv.org/abs/2510.26944", "authors": ["Hoa Nguyen", "Pongstorn Maidee", "Jason Lowe-Power", "Alireza Kaviani"], "title": "Choreographer: A Full-System Framework for Fine-Grained Tasks in Cache Hierarchies", "comment": null, "summary": "In this paper, we introduce Choreographer, a simulation framework that\nenables a holistic system-level evaluation of fine-grained accelerators\ndesigned for latency-sensitive tasks. Unlike existing frameworks, Choreographer\ncaptures all hardware and software overheads in core-accelerator and\ncache-accelerator interactions, integrating a detailed gem5-based hardware\nstack featuring an AMBA coherent hub interface (CHI) mesh network and a\ncomplete Linux-based software stack. To facilitate rapid prototyping, it offers\na C++ application programming interface and modular configuration options. Our\ndetailed cache model provides accurate insights into performance variations\ncaused by cache configurations, which are not captured by other frameworks. The\nframework is demonstrated through two case studies: a data-aware prefetcher for\ngraph analytics workloads, and a quicksort accelerator. Our evaluation shows\nthat the prefetcher achieves speedups between 1.08x and 1.88x by reducing\nmemory access latency, while the quicksort accelerator delivers more than 2x\nspeedup with minimal address translation overhead. These findings underscore\nthe ability of Choreographer to model complex hardware-software interactions\nand optimize performance in small task offloading scenarios."}
{"id": "2510.26985", "categories": ["cs.AR", "eess.SP"], "pdf": "https://arxiv.org/pdf/2510.26985", "abs": "https://arxiv.org/abs/2510.26985", "authors": ["Mostafa Darvishi"], "title": "Practical Timing Closure in FPGA and ASIC Designs: Methods, Challenges, and Case Studies", "comment": "5 figures, 3 tables", "summary": "This paper presents an in-depth analysis of timing closure challenges and\nconstraints in Field Programmable Gate Arrays (FPGAs) and Application Specific\nIntegrated Circuits (ASICs). We examine core timing principles, architectural\ndistinctions, and design methodologies influencing timing behavior in both\ntechnologies. A case study comparing the Xilinx Kintex UltraScale+ FPGA\n(XCKU040) with a 7nm ASIC highlights practical timing analysis and performance\ntrade-offs. Experimental results show ASICs achieve superior timing of 45ps\nsetup and 35ps hold, while modern FPGAs remain competitive with 180ps setup and\n120ps hold times, validating their suitability for high-performance designs."}
{"id": "2510.27070", "categories": ["cs.AR", "cs.CR"], "pdf": "https://arxiv.org/pdf/2510.27070", "abs": "https://arxiv.org/abs/2510.27070", "authors": ["Dong Tong"], "title": "Descriptor-Based Object-Aware Memory Systems: A Comprehensive Review", "comment": null, "summary": "The security and efficiency of modern computing systems are fundamentally\nundermined by the absence of a native architectural mechanism to propagate\nhigh-level program semantics, such as object identity, bounds, and lifetime,\nacross the hardware/software interface. This paper presents a comprehensive\nsurvey of the architectural paradigm designed to bridge this semantic gap:\ndescriptor-based, object-aware memory systems. By elevating the descriptor to a\nfirst-class architectural abstraction, this paradigm enables hardware to\ndynamically acquire and enforce the rich semantics of software-defined objects.\nThis survey systematically charts the evolution and current landscape of this\napproach. We establish the foundational concepts of memory objects and\ndescriptors and introduce a novel taxonomy of descriptor addressing modes,\nproviding a structured framework for analyzing and comparing diverse\nimplementations. Our unified analysis reveals how this paradigm holistically\naddresses the intertwined challenges of memory protection, management, and\nprocessing. As a culminating case study, we re-examine the CentroID model,\ndemonstrating how its hybrid tagged-pointer encoding and descriptor processing\nmechanisms embody the path toward practical and efficient object-aware designs.\nFinally, we outline how the explicit cross-layer communication of object\nsemantics provides a foundational research direction for next-generation cache\nhierarchies, unified virtual memory, and even 128-bit architectures."}
{"id": "2510.27107", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2510.27107", "abs": "https://arxiv.org/abs/2510.27107", "authors": ["Zhipeng Liao", "Kunming Shao", "Jiangnan Yu", "Liang Zhao", "Tim Kwang-Ting Cheng", "Chi-Ying Tsui", "Jie Yang", "Mohamad Sawan"], "title": "A Memory-Efficient Retrieval Architecture for RAG-Enabled Wearable Medical LLMs-Agents", "comment": "Accepted by BioCAS2025", "summary": "With powerful and integrative large language models (LLMs), medical AI agents\nhave demonstrated unique advantages in providing personalized medical\nconsultations, continuous health monitoring, and precise treatment plans.\nRetrieval-Augmented Generation (RAG) integrates personal medical documents into\nLLMs by an external retrievable database to address the costly retraining or\nfine-tuning issues in deploying customized agents. While deploying medical\nagents in edge devices ensures privacy protection, RAG implementations impose\nsubstantial memory access and energy consumption during the retrieval stage.\nThis paper presents a hierarchical retrieval architecture for edge RAG,\nleveraging a two-stage retrieval scheme that combines approximate retrieval for\ncandidate set generation, followed by high-precision retrieval on pre-selected\ndocument embeddings. The proposed architecture significantly reduces energy\nconsumption and external memory access while maintaining retrieval accuracy.\nSimulation results show that, under TSMC 28nm technology, the proposed\nhierarchical retrieval architecture has reduced the overall memory access by\nnearly 50% and the computation by 75% compared to pure INT8 retrieval, and the\ntotal energy consumption for 1 MB data retrieval is 177.76 {\\mu}J/query."}
