<div id=toc></div>

# Table of Contents

- [cs.AR](#cs.AR) [Total: 4]


<div id='cs.AR'></div>

# cs.AR [[Back]](#toc)

### [1] [Low-Cost IoT-Enabled Tele-ECG Monitoring for Resource-Constrained Settings: System Design and Prototype](https://arxiv.org/abs/2602.17114)
*Seemron Neupane,Aashish Ghimire*

Main category: cs.AR

TL;DR: 基于物联网的远程ECG监测系统，通过运营商、医生和服务器三方协作，实现心血管疾病的早期检测和远程医疗支持


<details>
  <summary>Details</summary>
Motivation: 随着自动化机械普及导致人们运动减少、疾病增多，许多地区缺乏基本医疗设施。心血管疾病（CDV）通过早期检测和干预可大幅治愈，但存在财务和物流负担。患者需要定期健康检查和紧急医疗关注，慢性疾病症状多变且需要及时治疗

Method: 采用物联网（IoT）技术构建远程ECG监测系统，重点关注三个主要组成部分：运营商（负责数据传输）、医生（提供医疗支持）和服务器（处理和分析数据）

Result: 远程ECG监测系统能够显著减少旅行和相关成本，使社区卫生工作者能够通过远程医疗支持和赋能患者，实现心血管疾病的早期检测和干预

Conclusion: 物联网技术在医疗领域的应用，特别是远程ECG监测系统，为解决医疗资源不足、降低医疗成本、实现早期疾病检测提供了有效解决方案，对心血管疾病管理具有重要意义

Abstract: With the availability of automation machinery and its superiority, are being slothful and inviting many diseases to invade them. The world still has so many places where people lack basic health facilities. Due to early detection and intervention, CDV can be cured to an extreme extent. It heavily reduces travel and associated costs. A remote ECG monitoring system enables community health workers to support and empower patients through telemedicine. However, there remains some financial and logistical burden. Heart disease cannot be taken lightly. These patients require regular health check-ups and the attention of health personnel in a short period if their health deteriorates suddenly and rapidly. Chronic diseases are extremely variable in their symptoms and evolution of treatment. Some, if not treated early, will end the patient's life. The trend of the INTERNET OF THINGS, IoT, is spreading massively. This paper focuses on the three main: the operator, the doctor, and the server over which the data is being sent.

</details>


### [2] [A Data-Driven Dynamic Execution Orchestration Architecture](https://arxiv.org/abs/2602.17119)
*Zhenyu Bai,Pranav Dangi,Rohan Juneja,Zhaoying Li,Zhanglu Yan,Huiying Lan,Tulika Mitra*

Main category: cs.AR

TL;DR: Canon是一种新型并行架构，通过动态数据驱动编排和时间错位SIMD执行，在保持通用架构灵活性的同时，实现了接近专用加速器的性能和效率。


<details>
  <summary>Details</summary>
Motivation: 专用加速器虽然针对特定工作负载具有优异性能，但对新内核或不规则输入模式表现脆弱；而可编程架构（如FPGA、CGRA、GPU）虽然支持更广泛应用，但在不规则或稀疏数据下效率较低。需要一种既能达到专用加速器效率，又能保持通用架构灵活性的设计。

Method: 1. 使用可编程有限状态机（FSM）实现动态数据驱动编排机制，在编译时编码高级数据流，运行时将元信息（如稀疏坐标）转换为控制指令；2. 引入时间错位SIMD执行，指令在多个周期内跨处理单元行发出，创建交错流水线执行。这些创新分摊了控制开销，允许动态指令更改，同时构建持续演化的数据流以最大化并行性。

Result: 实验评估表明，Canon在多种数据无关和数据驱动内核上都能提供高性能，同时实现与专用加速器相当的效率，同时保持通用架构的灵活性。

Conclusion: Canon成功弥合了专用架构和通用架构之间的差距，通过创新的动态编排和执行机制，在保持灵活性的同时实现了高性能和高效率，为可编程架构的发展提供了新方向。

Abstract: Domain-specific accelerators deliver exceptional performance on their target workloads through fabrication-time orchestrated datapaths. However, such specialized architectures often exhibit performance fragility when exposed to new kernels or irregular input patterns. In contrast, programmable architectures like FPGAs, CGRAs, and GPUs rely on compile-time orchestration to support a broader range of applications; but they are typically less efficient under irregular or sparse data. Pushing the boundaries of programmable architectures requires designs that can achieve efficiency and high-performance on par with specialized accelerators while retaining the agility of general-purpose architectures.
  We introduce Canon, a parallel architecture that bridges the gap between specialized and general purpose architectures. Canon exploits data-level and instruction-level parallelism through its novel design. First, it employs a novel dynamic data-driven orchestration mechanism using programmable Finite State Machines (FSMs). These FSMs are programmed at compile time to encode high-level dataflow per state and translate incoming meta-information (e.g., sparse coordinates) into control instructions at runtime. Second, Canon introduces a time-lapsed SIMD execution in which instructions are issued across a row of processing elements over several cycles, creating a staggered pipelined execution. These innovations amortize control overhead, allowing dynamic instruction changes while constructing a continuously evolving dataflow that maximizes parallelism. Experimental evaluation shows that Canon delivers high performance across diverse data-agnostic and data-driven kernels while achieving efficiency comparable to specialized accelerators, yet retaining the flexibility of a general-purpose architecture.

</details>


### [3] [SimulatorCoder: DNN Accelerator Simulator Code Generation and Optimization via Large Language Models](https://arxiv.org/abs/2602.17169)
*Yuhuan Xia,Tun Li,Hongji Zhou,Xianfa Zhou,Chong Chen,Ruiyu Zhang*

Main category: cs.AR

TL;DR: SimulatorCoder是一个基于大语言模型的智能体，能够根据自然语言描述自动生成和优化深度神经网络加速器模拟器代码。


<details>
  <summary>Details</summary>
Motivation: 传统DNN加速器模拟器开发需要大量手动编码工作，耗时且容易出错。研究旨在利用LLM自动化这一过程，加速模拟器开发流程。

Method: 结合领域特定的提示工程，包括上下文学习、思维链推理和多轮反馈验证流程，将高级功能需求系统性地转化为高效、可执行且架构对齐的模拟器代码。

Result: 在定制的SCALE-Sim基准测试中，结构化提示和反馈机制显著提高了代码生成准确性和模拟器性能。生成的模拟器与手动实现版本相比，周期级保真度误差小于1%，同时运行时间更低。

Conclusion: LLM方法在加速模拟器开发方面具有显著效果，能够生成高质量、高性能的模拟器代码，为硬件设计自动化提供了新途径。

Abstract: This paper presents SimulatorCoder, an agent powered by large language models (LLMs), designed to generate and optimize deep neural network (DNN) accelerator simulators based on natural language descriptions. By integrating domain-specific prompt engineering including In-Context Learning (ICL), Chain-of-Thought (CoT) reasoning, and a multi-round feedback-verification flow, SimulatorCoder systematically transforms high-level functional requirements into efficient, executable, and architecture-aligned simulator code. Experiments based on the customized SCALE-Sim benchmark demonstrate that structured prompting and feedback mechanisms substantially improve both code generation accuracy and simulator performance. The resulting simulators not only maintain cycle-level fidelity with less than 1% error compared to manually implemented counterparts, but also consistently achieve lower simulation runtimes, highlighting the effectiveness of LLM-based methods in accelerating simulator development. Our code is available at https://github.com/xiayuhuan/SimulatorCoder.

</details>


### [4] [When Models Ignore Definitions: Measuring Semantic Override Hallucinations in LLM Reasoning](https://arxiv.org/abs/2602.17520)
*Yogeswar Reddy Thota,Setareh Rafatirad,Homayoun Houman,Tooraj Nikoubin*

Main category: cs.AR

TL;DR: LLMs在标准数字逻辑任务上表现良好，但在局部重定义语义下会出现"语义覆盖"和"假设注入"的系统性故障，无法正确抑制预训练知识而遵循提示中的局部定义。


<details>
  <summary>Details</summary>
Motivation: 研究LLMs在局部重定义语义环境下的可靠性问题。在电路规范、考试、硬件文档等正式场景中，操作符和组件经常在狭窄范围内被显式重定义，但LLMs能否暂时抑制全局学习惯例而遵循提示中的局部定义尚不清楚。

Method: 创建包含30个逻辑和数字电路推理任务的微基准测试，涵盖布尔代数、操作符重载、重定义门和电路级语义，设计为验证器风格的陷阱。评估三个前沿LLM模型，观察它们在局部规范下的表现。

Result: 发现LLMs存在持续不遵守局部规范的问题，包括：语义覆盖（模型回归到预训练默认解释而忽略提示中的重定义）、假设注入（在关键细节未指定时做出未声明的硬件语义假设）、约束丢弃（即使在基本设置中也会忽略约束）。

Conclusion: LLMs在表面正确性和规范忠实推理之间存在差距，需要开发专门评估局部遗忘和语义合规性的测试协议，特别是在形式化领域中。

Abstract: Large language models (LLMs) demonstrate strong performance on standard digital logic and Boolean reasoning tasks, yet their reliability under locally redefined semantics remains poorly understood. In many formal settings, such as circuit specifications, examinations, and hardware documentation, operators and components are explicitly redefined within narrow scope. Correct reasoning in these contexts requires models to temporarily suppress globally learned conventions in favor of prompt-local definitions. In this work, we study a systematic failure mode we term semantic override, in which an LLM reverts to its pretrained default interpretation of operators or gate behavior despite explicit redefinition in the prompt. We also identify a related class of errors, assumption injection, where models commit to unstated hardware semantics when critical details are underspecified, rather than requesting clarification. We introduce a compact micro-benchmark of 30 logic and digital-circuit reasoning tasks designed as verifier-style traps, spanning Boolean algebra, operator overloading, redefined gates, and circuit-level semantics. Evaluating three frontier LLMs, we observe persistent noncompliance with local specifications, confident but incompatible assumptions, and dropped constraints even in elementary settings. Our findings highlight a gap between surface-level correctness and specification-faithful reasoning, motivating evaluation protocols that explicitly test local unlearning and semantic compliance in formal domains.

</details>
