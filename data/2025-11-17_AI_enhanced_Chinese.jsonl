{"id": "2511.10760", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2511.10760", "abs": "https://arxiv.org/abs/2511.10760", "authors": ["Emad Haque", "Pragnya Sudershan Nalla", "Jeff Zhang", "Sachin S. Sapatnekar", "Chaitali Chakrabarti", "Yu Cao"], "title": "Tiny Chiplets Enabled by Packaging Scaling: Opportunities in ESD Protection and Signal Integrity", "comment": null, "summary": "The scaling of advanced packaging technologies provides abundant interconnection resources for 2.5D/3D heterogeneous integration (HI), thereby enabling the construction of larger-scale VLSI systems with higher energy efficiency in data movement. However, conventional I/O circuitry, including electrostatic discharge (ESD) protection and signaling, introduces significant area overhead. Prior studies have identified this overhead as a major constraint in reducing chiplet size below 100 mm2. In this study, we revisit reliability requirements from the perspective of chiplet interface design. Through parasitic extraction and SPICE simulations, we demonstrate that ESD protection and inter-chiplet signaling can be substantially simplified in future 2.5D/3D packaging technologies. Such simplification, in turn, paves the road for further chiplet miniaturization and improves the composability and reusability of tiny chiplets.", "AI": {"tldr": "\u672c\u6587\u91cd\u65b0\u8bc4\u4f30\u4e862.5D/3D\u5f02\u6784\u96c6\u6210\u4e2d\u82af\u7247\u63a5\u53e3\u7684\u53ef\u9760\u6027\u8981\u6c42\uff0c\u63d0\u51fa\u53ef\u4ee5\u5927\u5e45\u7b80\u5316ESD\u4fdd\u62a4\u548c\u82af\u7247\u95f4\u4fe1\u53f7\u4f20\u8f93\uff0c\u4e3a\u66f4\u5c0f\u5c3a\u5bf8\u7684chiplet\u94fa\u5e73\u9053\u8def\u3002", "motivation": "\u4f20\u7edfI/O\u7535\u8def\uff08\u5305\u62ecESD\u4fdd\u62a4\u548c\u4fe1\u53f7\u4f20\u8f93\uff09\u5728\u5148\u8fdb\u5c01\u88c5\u6280\u672f\u4e2d\u5f15\u5165\u4e86\u663e\u8457\u7684\u9762\u79ef\u5f00\u9500\uff0c\u8fd9\u6210\u4e3a\u5c06chiplet\u5c3a\u5bf8\u51cf\u5c0f\u5230100mm2\u4ee5\u4e0b\u7684\u4e3b\u8981\u5236\u7ea6\u56e0\u7d20\u3002", "method": "\u901a\u8fc7\u5bc4\u751f\u53c2\u6570\u63d0\u53d6\u548cSPICE\u4eff\u771f\uff0c\u4ece\u82af\u7247\u63a5\u53e3\u8bbe\u8ba1\u7684\u89d2\u5ea6\u91cd\u65b0\u5ba1\u89c6\u53ef\u9760\u6027\u8981\u6c42\u3002", "result": "\u7814\u7a76\u8868\u660e\u5728\u672a\u6765\u76842.5D/3D\u5c01\u88c5\u6280\u672f\u4e2d\uff0cESD\u4fdd\u62a4\u548c\u82af\u7247\u95f4\u4fe1\u53f7\u4f20\u8f93\u53ef\u4ee5\u5927\u5e45\u7b80\u5316\u3002", "conclusion": "\u8fd9\u79cd\u7b80\u5316\u4e3a\u8fdb\u4e00\u6b65chiplet\u5c0f\u578b\u5316\u94fa\u5e73\u4e86\u9053\u8def\uff0c\u5e76\u63d0\u9ad8\u4e86\u5fae\u5c0fchiplet\u7684\u53ef\u7ec4\u5408\u6027\u548c\u53ef\u91cd\u7528\u6027\u3002"}}
{"id": "2511.10909", "categories": ["cs.AR", "cs.LG", "math.NA"], "pdf": "https://arxiv.org/pdf/2511.10909", "abs": "https://arxiv.org/abs/2511.10909", "authors": ["Peichen Xie", "Yang Wang", "Fan Yang", "Mao Yang"], "title": "MMA-Sim: Bit-Accurate Reference Model of Tensor Cores and Matrix Cores", "comment": null, "summary": "The rapidly growing computation demands of deep neural networks (DNNs) have driven hardware vendors to integrate matrix multiplication accelerators (MMAs), such as NVIDIA Tensor Cores and AMD Matrix Cores, into modern GPUs. However, due to distinct and undocumented arithmetic specifications for floating-point matrix multiplication, some MMAs can lead to numerical imprecision and inconsistency that can compromise the stability and reproducibility of DNN training and inference.\n  This paper presents MMA-Sim, the first bit-accurate reference model that reveals the detailed arithmetic behaviors of the MMAs from ten GPU architectures (eight from NVIDIA and two from AMD). By dissecting the MMAs using a combination of targeted and randomized tests, our methodology derives nine arithmetic algorithms to simulate the floating-point matrix multiplication of the MMAs. Large-scale validation confirms bitwise equivalence between MMA-Sim and the real hardware. Using MMA-Sim, we investigate arithmetic behaviors that affect DNN training stability, and identify undocumented behaviors that could lead to significant errors.", "AI": {"tldr": "MMA-Sim\u662f\u9996\u4e2a\u6bd4\u7279\u7ea7\u7cbe\u786e\u7684\u53c2\u8003\u6a21\u578b\uff0c\u63ed\u793a\u4e8610\u4e2aGPU\u67b6\u6784\u4e2d\u77e9\u9635\u4e58\u6cd5\u52a0\u901f\u5668\u7684\u8be6\u7ec6\u7b97\u672f\u884c\u4e3a\uff0c\u901a\u8fc7\u76ee\u6807\u6d4b\u8bd5\u548c\u968f\u673a\u6d4b\u8bd5\u63a8\u5bfc\u51fa9\u79cd\u7b97\u6cd5\u6765\u6a21\u62df\u6d6e\u70b9\u77e9\u9635\u4e58\u6cd5\u3002", "motivation": "\u7531\u4e8e\u4e0d\u540cGPU\u5382\u5546\u7684\u77e9\u9635\u4e58\u6cd5\u52a0\u901f\u5668\u5177\u6709\u72ec\u7279\u4e14\u672a\u516c\u5f00\u7684\u7b97\u672f\u89c4\u8303\uff0c\u53ef\u80fd\u5bfc\u81f4\u6570\u503c\u4e0d\u7cbe\u786e\u548c\u4e0d\u4e00\u81f4\uff0c\u4ece\u800c\u5f71\u54cd\u6df1\u5ea6\u795e\u7ecf\u7f51\u7edc\u8bad\u7ec3\u7684\u7a33\u5b9a\u6027\u548c\u53ef\u91cd\u73b0\u6027\u3002", "method": "\u7ed3\u5408\u76ee\u6807\u6d4b\u8bd5\u548c\u968f\u673a\u6d4b\u8bd5\uff0c\u5206\u679010\u4e2aGPU\u67b6\u6784\u7684\u77e9\u9635\u4e58\u6cd5\u52a0\u901f\u5668\uff0c\u63a8\u5bfc\u51fa9\u79cd\u7b97\u672f\u7b97\u6cd5\u6765\u6a21\u62df\u6d6e\u70b9\u77e9\u9635\u4e58\u6cd5\u884c\u4e3a\u3002", "result": "\u5927\u89c4\u6a21\u9a8c\u8bc1\u786e\u8ba4MMA-Sim\u4e0e\u771f\u5b9e\u786c\u4ef6\u5728\u6bd4\u7279\u7ea7\u522b\u4e0a\u7b49\u4ef7\uff0c\u5e76\u8bc6\u522b\u51fa\u53ef\u80fd\u5f15\u53d1\u663e\u8457\u9519\u8bef\u7684\u672a\u8bb0\u5f55\u884c\u4e3a\u3002", "conclusion": "MMA-Sim\u80fd\u591f\u51c6\u786e\u6a21\u62df\u77e9\u9635\u4e58\u6cd5\u52a0\u901f\u5668\u7684\u7b97\u672f\u884c\u4e3a\uff0c\u6709\u52a9\u4e8e\u7814\u7a76\u5f71\u54cdDNN\u8bad\u7ec3\u7a33\u5b9a\u6027\u7684\u7b97\u672f\u884c\u4e3a\uff0c\u5e76\u53d1\u73b0\u6f5c\u5728\u7684\u9519\u8bef\u6765\u6e90\u3002"}}
{"id": "2511.11248", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2511.11248", "abs": "https://arxiv.org/abs/2511.11248", "authors": ["Jianyu Wei", "Qingtao Li", "Shijie Cao", "Lingxiao Ma", "Zixu Hao", "Yanyong Zhang", "Xiaoyan Hu", "Ting Cao"], "title": "T-MAN: Enabling End-to-End Low-Bit LLM Inference on NPUs via Unified Table Lookup", "comment": null, "summary": "Large language models (LLMs) are increasingly deployed on customer devices. To support them, current devices are adopting SoCs (System on Chip) with NPUs (Neural Processing Unit) installed. Although high performance is expected, LLM inference on NPUs is slower than its CPU counterpart. The reason is that NPUs have poor performance on computations other than GEMM, like dequantization. Current works either disaggregate prefill on the NPUs and decoding on the CPUs, or put both on the NPUs but with an accuracy loss. To solve this issue, based on the insight that low-bit can enable target computation encoded within an acceptably sized table, we propose table lookup to subsume hardware operations otherwise unsupported. To realize this, we overcome the conflicting hardware behavior of prefill and decoding to design a unified table layout and tiling through (1) fused two-level table-based dequantization and (2) concurrency-hierarchy-guided tiling. Based on that, we implement the prefill phase by three-stage pipeline and map the table-lookup-based decoding to NPU's vector units. Results show 1.4x and 3.1x speedup for prefill and decoding respectively, and 84% energy savings compared to the baseline NPU methods. The code is available at https://github.com/microsoft/T-MAC/tree/main/t-man.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u4e00\u79cd\u57fa\u4e8e\u8868\u67e5\u627e\u7684\u65b9\u6cd5\u6765\u4f18\u5316NPU\u4e0a\u7684LLM\u63a8\u7406\uff0c\u901a\u8fc7\u878d\u5408\u4e24\u7ea7\u8868\u53bb\u91cf\u5316\u548c\u5e76\u53d1\u5c42\u6b21\u5f15\u5bfc\u7684\u5e73\u94fa\u6280\u672f\uff0c\u5b9e\u73b0\u4e86\u9884\u586b\u5145\u548c\u89e3\u7801\u9636\u6bb5\u7684\u6027\u80fd\u63d0\u5347\u548c\u80fd\u8017\u964d\u4f4e\u3002", "motivation": "\u5f53\u524dNPU\u5728LLM\u63a8\u7406\u4e2d\u6027\u80fd\u4e0d\u5982CPU\uff0c\u4e3b\u8981\u56e0\u4e3aNPU\u5728\u9664GEMM\u5916\u7684\u8ba1\u7b97\uff08\u5982\u53bb\u91cf\u5316\uff09\u4e0a\u8868\u73b0\u4e0d\u4f73\u3002\u73b0\u6709\u65b9\u6cd5\u8981\u4e48\u5728NPU\u548cCPU\u95f4\u62c6\u5206\u9884\u586b\u5145\u548c\u89e3\u7801\uff0c\u8981\u4e48\u5728NPU\u4e0a\u8fd0\u884c\u4f46\u635f\u5931\u7cbe\u5ea6\u3002", "method": "\u4f7f\u7528\u8868\u67e5\u627e\u66ff\u4ee3\u786c\u4ef6\u4e0d\u652f\u6301\u7684\u64cd\u4f5c\uff0c\u8bbe\u8ba1\u7edf\u4e00\u8868\u5e03\u5c40\u548c\u5e73\u94fa\uff1a(1) \u878d\u5408\u4e24\u7ea7\u8868\u53bb\u91cf\u5316 (2) \u5e76\u53d1\u5c42\u6b21\u5f15\u5bfc\u5e73\u94fa\u3002\u9884\u586b\u5145\u91c7\u7528\u4e09\u9636\u6bb5\u6d41\u6c34\u7ebf\uff0c\u89e3\u7801\u9636\u6bb5\u5c06\u8868\u67e5\u627e\u6620\u5c04\u5230NPU\u5411\u91cf\u5355\u5143\u3002", "result": "\u76f8\u6bd4\u57fa\u7ebfNPU\u65b9\u6cd5\uff0c\u9884\u586b\u5145\u901f\u5ea6\u63d0\u53471.4\u500d\uff0c\u89e3\u7801\u901f\u5ea6\u63d0\u53473.1\u500d\uff0c\u80fd\u8017\u8282\u770184%\u3002", "conclusion": "\u8868\u67e5\u627e\u65b9\u6cd5\u80fd\u6709\u6548\u89e3\u51b3NPU\u5728LLM\u63a8\u7406\u4e2d\u7684\u6027\u80fd\u74f6\u9888\uff0c\u5b9e\u73b0\u663e\u8457\u7684\u6027\u80fd\u63d0\u5347\u548c\u80fd\u8017\u964d\u4f4e\u3002"}}
