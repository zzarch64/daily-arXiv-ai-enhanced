{"id": "2510.06513", "categories": ["cs.AR", "cs.DC"], "pdf": "https://arxiv.org/pdf/2510.06513", "abs": "https://arxiv.org/abs/2510.06513", "authors": ["Debendra Das Sharma", "Swadesh Choudhary", "Peter Onufryk", "Rob Pelt"], "title": "On-Package Memory with Universal Chiplet Interconnect Express (UCIe): A Low Power, High Bandwidth, Low Latency and Low Cost Approach", "comment": "10 pages", "summary": "Emerging computing applications such as Artificial Intelligence (AI) are\nfacing a memory wall with existing on-package memory solutions that are unable\nto meet the power-efficient bandwidth demands. We propose to enhance UCIe with\nmemory semantics to deliver power-efficient bandwidth and cost-effective\non-package memory solutions applicable across the entire computing continuum.\nWe propose approaches by reusing existing LPDDR6 and HBM memory through a logic\ndie that connects to the SoC using UCIe. We also propose an approach where the\nDRAM die natively supports UCIe instead of the LPDDR6 bus interface. Our\napproaches result in significantly higher bandwidth density (up to 10x), lower\nlatency (up to 3x), lower power (up to 3x), and lower cost compared to existing\nHBM4 and LPDDR on-package memory solutions.", "AI": {"tldr": "\u63d0\u51fa\u901a\u8fc7\u589e\u5f3aUCIe\u63a5\u53e3\u652f\u6301\u5185\u5b58\u8bed\u4e49\uff0c\u4e3aAI\u7b49\u8ba1\u7b97\u5e94\u7528\u63d0\u4f9b\u9ad8\u5e26\u5bbd\u5bc6\u5ea6\u3001\u4f4e\u5ef6\u8fdf\u3001\u4f4e\u529f\u8017\u548c\u4f4e\u6210\u672c\u7684\u5c01\u88c5\u5185\u5185\u5b58\u89e3\u51b3\u65b9\u6848\u3002", "motivation": "\u73b0\u6709\u5c01\u88c5\u5185\u5185\u5b58\u89e3\u51b3\u65b9\u6848\u65e0\u6cd5\u6ee1\u8db3AI\u7b49\u65b0\u5174\u8ba1\u7b97\u5e94\u7528\u5bf9\u9ad8\u80fd\u6548\u5e26\u5bbd\u7684\u9700\u6c42\uff0c\u9762\u4e34\u5185\u5b58\u5899\u95ee\u9898\u3002", "method": "\u901a\u8fc7\u903b\u8f91\u82af\u7247\u590d\u7528LPDDR6\u548cHBM\u5185\u5b58\u8fde\u63a5\u5230SoC\u7684UCIe\u63a5\u53e3\uff0c\u4ee5\u53ca\u8ba9DRAM\u82af\u7247\u539f\u751f\u652f\u6301UCIe\u800c\u975eLPDDR6\u603b\u7ebf\u63a5\u53e3\u3002", "result": "\u76f8\u6bd4\u73b0\u6709HBM4\u548cLPDDR\u5c01\u88c5\u5185\u5185\u5b58\u89e3\u51b3\u65b9\u6848\uff0c\u5b9e\u73b0\u4e86\u663e\u8457\u66f4\u9ad8\u7684\u5e26\u5bbd\u5bc6\u5ea6\uff08\u6700\u9ad810\u500d\uff09\u3001\u66f4\u4f4e\u5ef6\u8fdf\uff08\u6700\u9ad83\u500d\uff09\u3001\u66f4\u4f4e\u529f\u8017\uff08\u6700\u9ad83\u500d\uff09\u548c\u66f4\u4f4e\u6210\u672c\u3002", "conclusion": "\u589e\u5f3aUCIe\u652f\u6301\u5185\u5b58\u8bed\u4e49\u662f\u89e3\u51b3\u8ba1\u7b97\u8fde\u7eed\u4f53\u4e2d\u5c01\u88c5\u5185\u5185\u5b58\u9700\u6c42\u7684\u6709\u6548\u65b9\u6cd5\u3002"}}
{"id": "2510.06644", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2510.06644", "abs": "https://arxiv.org/abs/2510.06644", "authors": ["Leshu Li", "Jiayin Qin", "Jie Peng", "Zishen Wan", "Huaizhi Qu", "Ye Han", "Pingqing Zheng", "Hongsen Zhang", "Yu", "Cao", "Tianlong Chen", "Yang", "Zhao"], "title": "RTGS: Real-Time 3D Gaussian Splatting SLAM via Multi-Level Redundancy Reduction", "comment": "Accepted by MICRO2025", "summary": "3D Gaussian Splatting (3DGS) based Simultaneous Localization and Mapping\n(SLAM) systems can largely benefit from 3DGS's state-of-the-art rendering\nefficiency and accuracy, but have not yet been adopted in resource-constrained\nedge devices due to insufficient speed. Addressing this, we identify notable\nredundancies across the SLAM pipeline for acceleration. While conceptually\nstraightforward, practical approaches are required to minimize the overhead\nassociated with identifying and eliminating these redundancies. In response, we\npropose RTGS, an algorithm-hardware co-design framework that comprehensively\nreduces the redundancies for real-time 3DGS-SLAM on edge. To minimize the\noverhead, RTGS fully leverages the characteristics of the 3DGS-SLAM pipeline.\nOn the algorithm side, we introduce (1) an adaptive Gaussian pruning step to\nremove the redundant Gaussians by reusing gradients computed during\nbackpropagation; and (2) a dynamic downsampling technique that directly reuses\nthe keyframe identification and alpha computing steps to eliminate redundant\npixels. On the hardware side, we propose (1) a subtile-level streaming strategy\nand a pixel-level pairwise scheduling strategy that mitigates workload\nimbalance via a Workload Scheduling Unit (WSU) guided by previous iteration\ninformation; (2) a Rendering and Backpropagation (R&B) Buffer that accelerates\nthe rendering backpropagation by reusing intermediate data computed during\nrendering; and (3) a Gradient Merging Unit (GMU) to reduce intensive memory\naccesses caused by atomic operations while enabling pipelined aggregation.\nIntegrated into an edge GPU, RTGS achieves real-time performance (>= 30 FPS) on\nfour datasets and three algorithms, with up to 82.5x energy efficiency over the\nbaseline and negligible quality loss. Code is available at\nhttps://github.com/UMN-ZhaoLab/RTGS.", "AI": {"tldr": "RTGS\u662f\u4e00\u4e2a\u7b97\u6cd5-\u786c\u4ef6\u534f\u540c\u8bbe\u8ba1\u6846\u67b6\uff0c\u901a\u8fc7\u51cf\u5c113D\u9ad8\u65af\u6cfc\u6e85SLAM\u7ba1\u9053\u4e2d\u7684\u5197\u4f59\u5b9e\u73b0\u8fb9\u7f18\u8bbe\u5907\u4e0a\u7684\u5b9e\u65f6\u6027\u80fd\uff0c\u5728\u4fdd\u6301\u8d28\u91cf\u7684\u540c\u65f6\u8fbe\u523030 FPS\u5e76\u63d0\u534782.5\u500d\u80fd\u6548\u3002", "motivation": "3D\u9ad8\u65af\u6cfc\u6e85SLAM\u7cfb\u7edf\u867d\u7136\u5177\u6709\u4f18\u5f02\u7684\u6e32\u67d3\u6548\u7387\u548c\u7cbe\u5ea6\uff0c\u4f46\u7531\u4e8e\u901f\u5ea6\u4e0d\u8db3\u5c1a\u672a\u5728\u8d44\u6e90\u53d7\u9650\u7684\u8fb9\u7f18\u8bbe\u5907\u4e0a\u5e94\u7528\uff0c\u9700\u8981\u89e3\u51b3\u7ba1\u9053\u4e2d\u7684\u5197\u4f59\u95ee\u9898\u4ee5\u5b9e\u73b0\u5b9e\u65f6\u6027\u80fd\u3002", "method": "\u7b97\u6cd5\u5c42\u9762\uff1a\u81ea\u9002\u5e94\u9ad8\u65af\u526a\u679d\u548c\u52a8\u6001\u4e0b\u91c7\u6837\u6280\u672f\uff1b\u786c\u4ef6\u5c42\u9762\uff1a\u5b50\u74e6\u7247\u7ea7\u6d41\u5f0f\u7b56\u7565\u3001\u50cf\u7d20\u7ea7\u914d\u5bf9\u8c03\u5ea6\u3001\u6e32\u67d3\u4e0e\u53cd\u5411\u4f20\u64ad\u7f13\u51b2\u533a\u3001\u68af\u5ea6\u5408\u5e76\u5355\u5143\u3002", "result": "\u5728\u56db\u4e2a\u6570\u636e\u96c6\u548c\u4e09\u79cd\u7b97\u6cd5\u4e0a\u5b9e\u73b0\u5b9e\u65f6\u6027\u80fd\uff08\u226530 FPS\uff09\uff0c\u80fd\u6548\u6bd4\u57fa\u7ebf\u63d0\u534782.5\u500d\uff0c\u8d28\u91cf\u635f\u5931\u53ef\u5ffd\u7565\u4e0d\u8ba1\u3002", "conclusion": "RTGS\u901a\u8fc7\u7b97\u6cd5-\u786c\u4ef6\u534f\u540c\u8bbe\u8ba1\u6709\u6548\u89e3\u51b3\u4e863DGS-SLAM\u5728\u8fb9\u7f18\u8bbe\u5907\u4e0a\u7684\u5b9e\u65f6\u8fd0\u884c\u95ee\u9898\uff0c\u4e3a\u8d44\u6e90\u53d7\u9650\u73af\u5883\u63d0\u4f9b\u4e86\u53ef\u884c\u7684\u89e3\u51b3\u65b9\u6848\u3002"}}
{"id": "2510.06767", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2510.06767", "abs": "https://arxiv.org/abs/2510.06767", "authors": ["Bindu G Gowda", "Yogesh Goyal", "Yash Gupta", "Madhav Rao"], "title": "Hardware-Efficient CNNs: Interleaved Approximate FP32 Multipliers for Kernel Computation", "comment": null, "summary": "Single-precision floating point (FP32) data format, defined by the IEEE 754\nstandard, is widely employed in scientific computing, signal processing, and\ndeep learning training, where precision is critical. However, FP32\nmultiplication is computationally expensive and requires complex hardware,\nespecially for precisely handling mantissa multiplication. In practical\napplications like neural network inference, perfect accuracy is not always\nnecessary, minor multiplication errors often have little impact on final\naccuracy. This enables trading precision for gains in area, power, and speed.\nThis work focuses on CNN inference using approximate FP32 multipliers, where\nthe mantissa multiplication is approximated by employing error-variant\napproximate compressors, that significantly reduce hardware cost. Furthermore,\nthis work optimizes CNN performance by employing differently approximated FP32\nmultipliers and studying their impact when interleaved within the kernels\nacross the convolutional layers. The placement and ordering of these\napproximate multipliers within each kernel are carefully optimized using the\nNon-dominated Sorting Genetic Algorithm-II, balancing the trade-off between\naccuracy and hardware efficiency.", "AI": {"tldr": "\u8be5\u8bba\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u7528\u4e8eCNN\u63a8\u7406\u7684\u8fd1\u4f3cFP32\u4e58\u6cd5\u5668\uff0c\u901a\u8fc7\u4f7f\u7528\u8bef\u5dee\u53ef\u53d8\u7684\u8fd1\u4f3c\u538b\u7f29\u5668\u6765\u8fd1\u4f3c\u5c3e\u6570\u4e58\u6cd5\uff0c\u663e\u8457\u964d\u4f4e\u786c\u4ef6\u6210\u672c\uff0c\u5e76\u91c7\u7528NSGA-II\u7b97\u6cd5\u4f18\u5316\u8fd1\u4f3c\u4e58\u6cd5\u5668\u5728\u5377\u79ef\u5c42\u4e2d\u7684\u5e03\u5c40\u4ee5\u5e73\u8861\u7cbe\u5ea6\u548c\u786c\u4ef6\u6548\u7387\u3002", "motivation": "FP32\u4e58\u6cd5\u5728\u786c\u4ef6\u5b9e\u73b0\u4e0a\u8ba1\u7b97\u6210\u672c\u9ad8\u4e14\u590d\u6742\uff0c\u4f46\u5728\u795e\u7ecf\u7f51\u7edc\u63a8\u7406\u7b49\u5e94\u7528\u4e2d\uff0c\u5b8c\u7f8e\u7cbe\u5ea6\u5e76\u975e\u5fc5\u9700\uff0c\u53ef\u4ee5\u727a\u7272\u4e00\u5b9a\u7cbe\u5ea6\u6765\u6362\u53d6\u9762\u79ef\u3001\u529f\u8017\u548c\u901f\u5ea6\u7684\u63d0\u5347\u3002", "method": "\u4f7f\u7528\u8bef\u5dee\u53ef\u53d8\u7684\u8fd1\u4f3c\u538b\u7f29\u5668\u6765\u8fd1\u4f3cFP32\u4e58\u6cd5\u5668\u7684\u5c3e\u6570\u4e58\u6cd5\u90e8\u5206\uff0c\u5e76\u91c7\u7528NSGA-II\u7b97\u6cd5\u4f18\u5316\u4e0d\u540c\u8fd1\u4f3c\u7a0b\u5ea6\u7684FP32\u4e58\u6cd5\u5668\u5728\u5377\u79ef\u5c42\u6838\u5185\u7684\u4ea4\u9519\u5e03\u5c40\u548c\u6392\u5e8f\u3002", "result": "\u63d0\u51fa\u7684\u8fd1\u4f3cFP32\u4e58\u6cd5\u5668\u663e\u8457\u964d\u4f4e\u4e86\u786c\u4ef6\u6210\u672c\uff0c\u540c\u65f6\u901a\u8fc7\u4f18\u5316\u5e03\u5c40\u7b56\u7565\u5728CNN\u63a8\u7406\u4e2d\u5b9e\u73b0\u4e86\u7cbe\u5ea6\u548c\u786c\u4ef6\u6548\u7387\u7684\u826f\u597d\u5e73\u8861\u3002", "conclusion": "\u8fd1\u4f3cFP32\u4e58\u6cd5\u5668\u7ed3\u5408\u667a\u80fd\u5e03\u5c40\u4f18\u5316\u7b56\u7565\uff0c\u4e3aCNN\u63a8\u7406\u63d0\u4f9b\u4e86\u4e00\u79cd\u6709\u6548\u7684\u786c\u4ef6\u4f18\u5316\u65b9\u6848\uff0c\u5728\u53ef\u63a5\u53d7\u7684\u7cbe\u5ea6\u635f\u5931\u4e0b\u663e\u8457\u63d0\u5347\u4e86\u786c\u4ef6\u6548\u7387\u3002"}}
{"id": "2510.07304", "categories": ["cs.AR", "cs.AI", "cs.CR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.07304", "abs": "https://arxiv.org/abs/2510.07304", "authors": ["Donghwan Kim", "Xin Gu", "Jinho Baek", "Timothy Lo", "Younghoon Min", "Kwangsik Shin", "Jongryool Kim", "Jongse Park", "Kiwan Maeng"], "title": "Cocoon: A System Architecture for Differentially Private Training with Correlated Noises", "comment": null, "summary": "Machine learning (ML) models memorize and leak training data, causing serious\nprivacy issues to data owners. Training algorithms with differential privacy\n(DP), such as DP-SGD, have been gaining attention as a solution. However,\nDP-SGD adds a noise at each training iteration, which degrades the accuracy of\nthe trained model. To improve accuracy, a new family of approaches adds\ncarefully designed correlated noises, so that noises cancel out each other\nacross iterations. We performed an extensive characterization study of these\nnew mechanisms, for the first time to the best of our knowledge, and show they\nincur non-negligible overheads when the model is large or uses large embedding\ntables. Motivated by the analysis, we propose Cocoon, a hardware-software\nco-designed framework for efficient training with correlated noises. Cocoon\naccelerates models with embedding tables through pre-computing and storing\ncorrelated noises in a coalesced format (Cocoon-Emb), and supports large models\nthrough a custom near-memory processing device (Cocoon-NMP). On a real system\nwith an FPGA-based NMP device prototype, Cocoon improves the performance by\n2.33-10.82x(Cocoon-Emb) and 1.55-3.06x (Cocoon-NMP).", "AI": {"tldr": "\u672c\u6587\u7814\u7a76\u4e86\u4f7f\u7528\u76f8\u5173\u566a\u58f0\u7684\u5dee\u5206\u9690\u79c1\u8bad\u7ec3\u65b9\u6cd5\uff0c\u5206\u6790\u4e86\u5176\u5728\u5927\u6a21\u578b\u548c\u5927\u5d4c\u5165\u8868\u4e0a\u7684\u6027\u80fd\u5f00\u9500\uff0c\u5e76\u63d0\u51fa\u4e86Cocoon\u786c\u4ef6-\u8f6f\u4ef6\u534f\u540c\u8bbe\u8ba1\u6846\u67b6\u6765\u52a0\u901f\u76f8\u5173\u566a\u58f0\u8bad\u7ec3\u3002", "motivation": "\u673a\u5668\u5b66\u4e60\u6a21\u578b\u4f1a\u8bb0\u5fc6\u548c\u6cc4\u9732\u8bad\u7ec3\u6570\u636e\uff0c\u5e26\u6765\u4e25\u91cd\u7684\u9690\u79c1\u95ee\u9898\u3002\u867d\u7136\u5dee\u5206\u9690\u79c1\u8bad\u7ec3(\u5982DP-SGD)\u53ef\u4ee5\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u4f46\u4f1a\u964d\u4f4e\u6a21\u578b\u51c6\u786e\u6027\u3002\u65b0\u7684\u76f8\u5173\u566a\u58f0\u65b9\u6cd5\u80fd\u63d0\u9ad8\u51c6\u786e\u6027\uff0c\u4f46\u5728\u5927\u6a21\u578b\u548c\u5927\u5d4c\u5165\u8868\u4e0a\u4f1a\u4ea7\u751f\u663e\u8457\u5f00\u9500\u3002", "method": "\u63d0\u51faCocoon\u6846\u67b6\uff1a1) Cocoon-Emb\u901a\u8fc7\u9884\u8ba1\u7b97\u548c\u5b58\u50a8\u5408\u5e76\u683c\u5f0f\u7684\u76f8\u5173\u566a\u58f0\u6765\u52a0\u901f\u5e26\u5d4c\u5165\u8868\u7684\u6a21\u578b\uff1b2) Cocoon-NMP\u901a\u8fc7\u5b9a\u5236\u8fd1\u5185\u5b58\u5904\u7406\u8bbe\u5907\u652f\u6301\u5927\u6a21\u578b\u3002", "result": "\u5728\u57fa\u4e8eFPGA\u7684NMP\u8bbe\u5907\u539f\u578b\u4e0a\uff0cCocoon\u5c06\u6027\u80fd\u63d0\u5347\u4e862.33-10.82\u500d(Cocoon-Emb)\u548c1.55-3.06\u500d(Cocoon-NMP)\u3002", "conclusion": "Cocoon\u786c\u4ef6-\u8f6f\u4ef6\u534f\u540c\u8bbe\u8ba1\u6846\u67b6\u80fd\u6709\u6548\u89e3\u51b3\u76f8\u5173\u566a\u58f0\u5dee\u5206\u9690\u79c1\u8bad\u7ec3\u5728\u5927\u6a21\u578b\u548c\u5927\u5d4c\u5165\u8868\u4e0a\u7684\u6027\u80fd\u74f6\u9888\uff0c\u663e\u8457\u63d0\u5347\u8bad\u7ec3\u6548\u7387\u3002"}}
