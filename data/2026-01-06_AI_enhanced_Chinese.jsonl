{"id": "2601.01158", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2601.01158", "abs": "https://arxiv.org/abs/2601.01158", "authors": ["Yilun Zhao", "Yu Chen", "Kaiyan Chang", "He Li", "Bing Li", "Yinhe Han", "Ying Wang"], "title": "A System Architecture for Low Latency Multiprogramming Quantum Computing", "comment": null, "summary": "As quantum systems scale, Multiprogramming Quantum Computing (MPQC) becomes essential to improve device utilization and throughput. However, current MPQC pipelines rely on expensive online compilation to co-optimize concurrently running programs, because quantum executables are device-dependent, non-portable across qubit regions, and highly susceptible to noise and crosstalk. This online step dominates runtime and impedes low-latency deployments for practical, real-world workloads in the future, such as repeatedly invoked Quantum Neural Network (QNN) services.\n  We present FLAMENCO, a fidelity-aware multi-version compilation system that enables independent offline compilation and low-latency, high-fidelity multiprogramming at runtime. At the architecture level, FLAMENCO abstracts devices into compute units to drastically shrink the search space of region allocation. At compile time, it generates diverse executable versions for each program -- each bound to a distinct qubit region -- allowing dynamic region selection at runtime and overcoming non-portability. At runtime, FLAMENCO employs a streamlined orchestrator that leverages post-compilation fidelity metrics to avoid conflicts and mitigate crosstalk, achieving reliable co-execution without online co-optimization. Comprehensive evaluations against state-of-the-art MPQC baselines show that FLAMENCO removes online compilation overhead, achieves over 5$\\times$ runtime speedup, improves execution fidelity, and maintains high utilization as concurrency increases.", "AI": {"tldr": "FLAMENCO\u662f\u4e00\u4e2a\u4fdd\u771f\u5ea6\u611f\u77e5\u7684\u591a\u7248\u672c\u7f16\u8bd1\u7cfb\u7edf\uff0c\u901a\u8fc7\u79bb\u7ebf\u7f16\u8bd1\u548c\u8fd0\u884c\u65f6\u52a8\u6001\u533a\u57df\u9009\u62e9\uff0c\u6d88\u9664\u91cf\u5b50\u591a\u7a0b\u5e8f\u8ba1\u7b97\u4e2d\u7684\u5728\u7ebf\u7f16\u8bd1\u5f00\u9500\uff0c\u5b9e\u73b0\u4f4e\u5ef6\u8fdf\u3001\u9ad8\u4fdd\u771f\u5ea6\u7684\u591a\u7a0b\u5e8f\u6267\u884c\u3002", "motivation": "\u968f\u7740\u91cf\u5b50\u7cfb\u7edf\u89c4\u6a21\u6269\u5927\uff0c\u591a\u7a0b\u5e8f\u91cf\u5b50\u8ba1\u7b97(MPQC)\u5bf9\u63d0\u9ad8\u8bbe\u5907\u5229\u7528\u7387\u548c\u541e\u5410\u91cf\u81f3\u5173\u91cd\u8981\u3002\u7136\u800c\uff0c\u5f53\u524dMPQC\u6d41\u6c34\u7ebf\u4f9d\u8d56\u6602\u8d35\u7684\u5728\u7ebf\u7f16\u8bd1\u6765\u534f\u540c\u4f18\u5316\u5e76\u53d1\u8fd0\u884c\u7684\u7a0b\u5e8f\uff0c\u56e0\u4e3a\u91cf\u5b50\u53ef\u6267\u884c\u6587\u4ef6\u662f\u8bbe\u5907\u4f9d\u8d56\u7684\u3001\u8de8\u91cf\u5b50\u6bd4\u7279\u533a\u57df\u4e0d\u53ef\u79fb\u690d\u7684\uff0c\u5e76\u4e14\u5bf9\u566a\u58f0\u548c\u4e32\u6270\u9ad8\u5ea6\u654f\u611f\u3002\u8fd9\u4e2a\u5728\u7ebf\u6b65\u9aa4\u4e3b\u5bfc\u4e86\u8fd0\u884c\u65f6\uff0c\u963b\u788d\u4e86\u672a\u6765\u5b9e\u9645\u5de5\u4f5c\u8d1f\u8f7d\uff08\u5982\u91cd\u590d\u8c03\u7528\u7684\u91cf\u5b50\u795e\u7ecf\u7f51\u7edc\u670d\u52a1\uff09\u7684\u4f4e\u5ef6\u8fdf\u90e8\u7f72\u3002", "method": "1) \u67b6\u6784\u5c42\u9762\uff1a\u5c06\u8bbe\u5907\u62bd\u8c61\u4e3a\u8ba1\u7b97\u5355\u5143\uff0c\u5927\u5e45\u7f29\u5c0f\u533a\u57df\u5206\u914d\u7684\u641c\u7d22\u7a7a\u95f4\uff1b2) \u7f16\u8bd1\u65f6\uff1a\u4e3a\u6bcf\u4e2a\u7a0b\u5e8f\u751f\u6210\u7ed1\u5b9a\u5230\u4e0d\u540c\u91cf\u5b50\u6bd4\u7279\u533a\u57df\u7684\u591a\u6837\u5316\u53ef\u6267\u884c\u7248\u672c\uff0c\u5b9e\u73b0\u8fd0\u884c\u65f6\u52a8\u6001\u533a\u57df\u9009\u62e9\uff1b3) \u8fd0\u884c\u65f6\uff1a\u91c7\u7528\u7b80\u5316\u7684\u7f16\u6392\u5668\uff0c\u5229\u7528\u7f16\u8bd1\u540e\u4fdd\u771f\u5ea6\u6307\u6807\u907f\u514d\u51b2\u7a81\u548c\u51cf\u8f7b\u4e32\u6270\uff0c\u5b9e\u73b0\u65e0\u9700\u5728\u7ebf\u534f\u540c\u4f18\u5316\u7684\u53ef\u9760\u534f\u540c\u6267\u884c\u3002", "result": "\u4e0e\u6700\u5148\u8fdb\u7684MPQC\u57fa\u7ebf\u76f8\u6bd4\uff0cFLAMENCO\u6d88\u9664\u4e86\u5728\u7ebf\u7f16\u8bd1\u5f00\u9500\uff0c\u5b9e\u73b0\u4e86\u8d85\u8fc75\u500d\u7684\u8fd0\u884c\u65f6\u52a0\u901f\uff0c\u63d0\u9ad8\u4e86\u6267\u884c\u4fdd\u771f\u5ea6\uff0c\u5e76\u5728\u5e76\u53d1\u589e\u52a0\u65f6\u4fdd\u6301\u9ad8\u5229\u7528\u7387\u3002", "conclusion": "FLAMENCO\u901a\u8fc7\u4fdd\u771f\u5ea6\u611f\u77e5\u7684\u591a\u7248\u672c\u7f16\u8bd1\u7cfb\u7edf\uff0c\u5b9e\u73b0\u4e86\u72ec\u7acb\u79bb\u7ebf\u7f16\u8bd1\u548c\u8fd0\u884c\u65f6\u4f4e\u5ef6\u8fdf\u3001\u9ad8\u4fdd\u771f\u5ea6\u7684\u591a\u7a0b\u5e8f\u91cf\u5b50\u8ba1\u7b97\uff0c\u89e3\u51b3\u4e86\u5f53\u524dMPQC\u6d41\u6c34\u7ebf\u4e2d\u5728\u7ebf\u7f16\u8bd1\u4e3b\u5bfc\u8fd0\u884c\u65f6\u7684\u5173\u952e\u74f6\u9888\u3002"}}
{"id": "2601.01265", "categories": ["cs.AR", "cs.OS", "cs.PF"], "pdf": "https://arxiv.org/pdf/2601.01265", "abs": "https://arxiv.org/abs/2601.01265", "authors": ["Nick Lindsay", "Caroline Trippel", "Anurag Khandelwal", "Abhishek Bhattacharjee"], "title": "CounterPoint: Using Hardware Event Counters to Refute and Refine Microarchitectural Assumptions (Extended Version)", "comment": "This is an extended version of a paper which has been accepted to the 31st ACM International Conference on Architectural Support for Programming Languages and Operating Systems conference (ASPLOS, March 2026). 20 pages, 20 figures, 8 tables", "summary": "Hardware event counters offer the potential to reveal not only performance bottlenecks but also detailed microarchitectural behavior. In practice, this promise is undermined by their vague specifications, opaque designs, and multiplexing noise, making event counter data hard to interpret.\n  We introduce CounterPoint, a framework that tests user-specified microarchitectural models - expressed as $\u03bc$path Decision Diagrams - for consistency with performance counter data. When mismatches occur, CounterPoint pinpoints plausible microarchitectural features that could explain them, using multi-dimensional counter confidence regions to mitigate multiplexing noise. We apply CounterPoint to the Haswell Memory Management Unit as a case study, shedding light on multiple undocumented and underdocumented microarchitectural behaviors. These include a load-store queue-side TLB prefetcher, merging page table walkers, abortable page table walks, and more.\n  Overall, CounterPoint helps experts reconcile noisy hardware performance counter measurements with their mental model of the microarchitecture - uncovering subtle, previously hidden hardware features along the way.", "AI": {"tldr": "CounterPoint\u662f\u4e00\u4e2a\u6846\u67b6\uff0c\u901a\u8fc7\u6d4b\u8bd5\u7528\u6237\u6307\u5b9a\u7684\u5fae\u67b6\u6784\u6a21\u578b\u4e0e\u6027\u80fd\u8ba1\u6570\u5668\u6570\u636e\u7684\u4e00\u81f4\u6027\uff0c\u5e2e\u52a9\u4e13\u5bb6\u89e3\u91ca\u6a21\u7cca\u7684\u786c\u4ef6\u6027\u80fd\u8ba1\u6570\u5668\u6570\u636e\uff0c\u5e76\u53d1\u73b0\u672a\u6587\u6863\u5316\u7684\u5fae\u67b6\u6784\u884c\u4e3a\u3002", "motivation": "\u786c\u4ef6\u4e8b\u4ef6\u8ba1\u6570\u5668\u867d\u7136\u80fd\u63ed\u793a\u6027\u80fd\u74f6\u9888\u548c\u5fae\u67b6\u6784\u884c\u4e3a\uff0c\u4f46\u7531\u4e8e\u5176\u89c4\u8303\u6a21\u7cca\u3001\u8bbe\u8ba1\u4e0d\u900f\u660e\u4ee5\u53ca\u591a\u8def\u590d\u7528\u566a\u58f0\uff0c\u4f7f\u5f97\u8ba1\u6570\u5668\u6570\u636e\u96be\u4ee5\u89e3\u91ca\u3002\u9700\u8981\u4e00\u79cd\u65b9\u6cd5\u6765\u9a8c\u8bc1\u5fae\u67b6\u6784\u6a21\u578b\u4e0e\u5b9e\u6d4b\u6570\u636e\u7684\u4e00\u81f4\u6027\u3002", "method": "\u63d0\u51faCounterPoint\u6846\u67b6\uff0c\u4f7f\u7528\u03bc\u8def\u5f84\u51b3\u7b56\u56fe\u8868\u8fbe\u7528\u6237\u6307\u5b9a\u7684\u5fae\u67b6\u6784\u6a21\u578b\uff0c\u6d4b\u8bd5\u8fd9\u4e9b\u6a21\u578b\u4e0e\u6027\u80fd\u8ba1\u6570\u5668\u6570\u636e\u7684\u4e00\u81f4\u6027\u3002\u5f53\u51fa\u73b0\u4e0d\u5339\u914d\u65f6\uff0c\u901a\u8fc7\u591a\u7ef4\u8ba1\u6570\u5668\u7f6e\u4fe1\u533a\u57df\u6765\u51cf\u8f7b\u591a\u8def\u590d\u7528\u566a\u58f0\uff0c\u5e76\u5b9a\u4f4d\u53ef\u80fd\u89e3\u91ca\u8fd9\u4e9b\u4e0d\u5339\u914d\u7684\u5fae\u67b6\u6784\u7279\u5f81\u3002", "result": "\u5c06CounterPoint\u5e94\u7528\u4e8eHaswell\u5185\u5b58\u7ba1\u7406\u5355\u5143\u4f5c\u4e3a\u6848\u4f8b\u7814\u7a76\uff0c\u63ed\u793a\u4e86\u591a\u4e2a\u672a\u6587\u6863\u5316\u6216\u6587\u6863\u4e0d\u8db3\u7684\u5fae\u67b6\u6784\u884c\u4e3a\uff0c\u5305\u62ec\uff1a\u52a0\u8f7d\u5b58\u50a8\u961f\u5217\u4fa7\u7684TLB\u9884\u53d6\u5668\u3001\u5408\u5e76\u9875\u8868\u904d\u5386\u5668\u3001\u53ef\u4e2d\u6b62\u7684\u9875\u8868\u904d\u5386\u7b49\u3002", "conclusion": "CounterPoint\u5e2e\u52a9\u4e13\u5bb6\u5c06\u566a\u58f0\u786c\u4ef6\u6027\u80fd\u8ba1\u6570\u5668\u6d4b\u91cf\u7ed3\u679c\u4e0e\u4ed6\u4eec\u5bf9\u5fae\u67b6\u6784\u7684\u5fc3\u7406\u6a21\u578b\u76f8\u534f\u8c03\uff0c\u5728\u6b64\u8fc7\u7a0b\u4e2d\u53d1\u73b0\u5fae\u5999\u3001\u5148\u524d\u9690\u85cf\u7684\u786c\u4ef6\u7279\u5f81\u3002"}}
{"id": "2601.02053", "categories": ["cs.AR", "eess.SY"], "pdf": "https://arxiv.org/pdf/2601.02053", "abs": "https://arxiv.org/abs/2601.02053", "authors": ["Leandro Lanzieri", "Jiri Kral", "Goerschwin Fey", "Holger Schlarb", "Thomas C. Schmidt"], "title": "Ageing Monitoring for Commercial Microcontrollers Based on Timing Windows", "comment": null, "summary": "Microcontrollers are increasingly present in embedded deployments and dependable applications, for which malfunctions due to hardware ageing can have severe impact. The lack of deployable techniques for ageing monitoring on these devices has spread the application of guard bands to prevent timing errors due to degradation. Applying this static technique can limit performance and lead to sudden failures as devices age. In this paper, we follow a software-based self-testing approach to design monitoring of hardware degradation for microcontrollers. Deployable in the field, our technique leverages timing windows of variable lengths to determine the maximum operational frequency of the devices. We empirically validate the method on real hardware and find that it consistently detects temperature-induced degradations in maximum operating frequency of up to 13.79 % across devices for 60 \u00b0C temperature increase.", "AI": {"tldr": "\u63d0\u51fa\u4e00\u79cd\u57fa\u4e8e\u8f6f\u4ef6\u81ea\u6d4b\u8bd5\u7684\u5fae\u63a7\u5236\u5668\u786c\u4ef6\u8001\u5316\u76d1\u6d4b\u65b9\u6cd5\uff0c\u901a\u8fc7\u53ef\u53d8\u957f\u5ea6\u65f6\u95f4\u7a97\u53e3\u786e\u5b9a\u8bbe\u5907\u6700\u5927\u5de5\u4f5c\u9891\u7387\uff0c\u53ef\u73b0\u573a\u90e8\u7f72\u68c0\u6d4b\u6e29\u5ea6\u5f15\u8d77\u7684\u6027\u80fd\u9000\u5316", "motivation": "\u5fae\u63a7\u5236\u5668\u5728\u5d4c\u5165\u5f0f\u7cfb\u7edf\u548c\u53ef\u9760\u6027\u5e94\u7528\u4e2d\u65e5\u76ca\u666e\u53ca\uff0c\u786c\u4ef6\u8001\u5316\u5bfc\u81f4\u7684\u6545\u969c\u53ef\u80fd\u4ea7\u751f\u4e25\u91cd\u5f71\u54cd\u3002\u76ee\u524d\u7f3a\u4e4f\u53ef\u90e8\u7f72\u7684\u8001\u5316\u76d1\u6d4b\u6280\u672f\uff0c\u666e\u904d\u91c7\u7528\u4fdd\u62a4\u5e26\u65b9\u6cd5\u9632\u6b62\u9000\u5316\u5f15\u8d77\u7684\u65f6\u5e8f\u9519\u8bef\uff0c\u4f46\u8fd9\u79cd\u9759\u6001\u6280\u672f\u4f1a\u9650\u5236\u6027\u80fd\u5e76\u53ef\u80fd\u5bfc\u81f4\u8bbe\u5907\u8001\u5316\u65f6\u7a81\u7136\u5931\u6548\u3002", "method": "\u91c7\u7528\u57fa\u4e8e\u8f6f\u4ef6\u7684\u81ea\u6d4b\u8bd5\u65b9\u6cd5\u8bbe\u8ba1\u5fae\u63a7\u5236\u5668\u786c\u4ef6\u9000\u5316\u76d1\u6d4b\u6280\u672f\u3002\u8be5\u65b9\u6cd5\u5229\u7528\u53ef\u53d8\u957f\u5ea6\u7684\u65f6\u95f4\u7a97\u53e3\u6765\u786e\u5b9a\u8bbe\u5907\u7684\u6700\u5927\u5de5\u4f5c\u9891\u7387\uff0c\u53ef\u5728\u73b0\u573a\u90e8\u7f72\u3002", "result": "\u5728\u771f\u5b9e\u786c\u4ef6\u4e0a\u7ecf\u9a8c\u9a8c\u8bc1\uff0c\u8be5\u65b9\u6cd5\u80fd\u4e00\u81f4\u68c0\u6d4b\u5230\u6e29\u5ea6\u5f15\u8d77\u7684\u6700\u5927\u5de5\u4f5c\u9891\u7387\u9000\u5316\uff0c\u5728\u6e29\u5ea6\u5347\u9ad860\u00b0C\u65f6\uff0c\u4e0d\u540c\u8bbe\u5907\u7684\u9891\u7387\u9000\u5316\u6700\u9ad8\u53ef\u8fbe13.79%\u3002", "conclusion": "\u63d0\u51fa\u7684\u8f6f\u4ef6\u81ea\u6d4b\u8bd5\u65b9\u6cd5\u80fd\u6709\u6548\u76d1\u6d4b\u5fae\u63a7\u5236\u5668\u786c\u4ef6\u9000\u5316\uff0c\u89e3\u51b3\u4e86\u4f20\u7edf\u4fdd\u62a4\u5e26\u65b9\u6cd5\u7684\u5c40\u9650\u6027\uff0c\u4e3a\u5d4c\u5165\u5f0f\u7cfb\u7edf\u7684\u53ef\u9760\u6027\u63d0\u4f9b\u4e86\u52a8\u6001\u76d1\u6d4b\u89e3\u51b3\u65b9\u6848\u3002"}}
{"id": "2601.02135", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2601.02135", "abs": "https://arxiv.org/abs/2601.02135", "authors": ["Liu Shijie", "Zeng Zhenghao", "Jiao Han", "Huang Yihua"], "title": "HFRWKV: A High-Performance Fully On-Chip Hardware Accelerator for RWKV", "comment": null, "summary": "RWKV is a modern RNN architecture that approaches the performance of Transformers, with the advantage of processing long contexts at a linear memory cost. However, its sequential computation pattern struggles to efficiently leverage GPU parallelism, which leads to low compute resource utilization. Furthermore, frequent off-chip weight accesses create a memory bottleneck. To address these challenges, we propose HFRWKV, an FPGA-based hardware accelerator specifically designed for RWKV. Within the matrix operation module, we propose a novel hardware-friendly hybrid-precision quantization strategy, which enhances performance while maintaining acceptable accuracy. For the complex operations including exponentiation and division, we introduce a method featuring reusable architectures combined with lookup tables or piecewise linear approximation, which is algorithmically refined to effectively balance precision and hardware resource consumption. Based on this foundation, we adopt a fully on-chip computing system integrating parallel matrix-vector processing array and an efficient pipeline architecture. Through computation reordering and chunked double buffering, it effectively eliminates data transfer bottlenecks and improves overall throughput. We implement HFRWKV on the Alveo U50 and U280 platform. Experimental results show that compared to a CPU, a throughput improvement of 63.48$\\times$ and an energy efficiency improvement of 139.17$\\times$. Compared to GPUs, achieves a throughput improvement of 32.33$\\times$ and an energy efficiency improvement of 171.36$\\times$.", "AI": {"tldr": "HFRWKV\uff1a\u9488\u5bf9RWKV\u6a21\u578b\u7684FPGA\u786c\u4ef6\u52a0\u901f\u5668\uff0c\u901a\u8fc7\u6df7\u5408\u7cbe\u5ea6\u91cf\u5316\u3001\u53ef\u590d\u7528\u67b6\u6784\u548c\u5168\u7247\u4e0a\u8ba1\u7b97\u7cfb\u7edf\uff0c\u663e\u8457\u63d0\u5347\u541e\u5410\u91cf\u548c\u80fd\u6548", "motivation": "RWKV\u4f5c\u4e3a\u73b0\u4ee3RNN\u67b6\u6784\u5728\u5904\u7406\u957f\u4e0a\u4e0b\u6587\u65f6\u5177\u6709\u7ebf\u6027\u5185\u5b58\u4f18\u52bf\uff0c\u4f46\u5176\u987a\u5e8f\u8ba1\u7b97\u6a21\u5f0f\u96be\u4ee5\u5145\u5206\u5229\u7528GPU\u5e76\u884c\u6027\uff0c\u4e14\u9891\u7e41\u7684\u7247\u5916\u6743\u91cd\u8bbf\u95ee\u9020\u6210\u5185\u5b58\u74f6\u9888", "method": "1\uff09\u63d0\u51fa\u786c\u4ef6\u53cb\u597d\u7684\u6df7\u5408\u7cbe\u5ea6\u91cf\u5316\u7b56\u7565\uff1b2\uff09\u9488\u5bf9\u6307\u6570\u548c\u9664\u6cd5\u7b49\u590d\u6742\u8fd0\u7b97\uff0c\u91c7\u7528\u53ef\u590d\u7528\u67b6\u6784\u7ed3\u5408\u67e5\u627e\u8868\u6216\u5206\u6bb5\u7ebf\u6027\u8fd1\u4f3c\uff1b3\uff09\u91c7\u7528\u5168\u7247\u4e0a\u8ba1\u7b97\u7cfb\u7edf\uff0c\u96c6\u6210\u5e76\u884c\u77e9\u9635\u5411\u91cf\u5904\u7406\u9635\u5217\u548c\u9ad8\u6548\u6d41\u6c34\u7ebf\u67b6\u6784\uff1b4\uff09\u901a\u8fc7\u8ba1\u7b97\u91cd\u6392\u5e8f\u548c\u5206\u5757\u53cc\u7f13\u51b2\u6d88\u9664\u6570\u636e\u4f20\u8f93\u74f6\u9888", "result": "\u5728Alveo U50\u548cU280\u5e73\u53f0\u4e0a\u5b9e\u73b0\uff0c\u76f8\u6bd4CPU\u5b9e\u73b063.48\u500d\u541e\u5410\u91cf\u63d0\u5347\u548c139.17\u500d\u80fd\u6548\u63d0\u5347\uff1b\u76f8\u6bd4GPU\u5b9e\u73b032.33\u500d\u541e\u5410\u91cf\u63d0\u5347\u548c171.36\u500d\u80fd\u6548\u63d0\u5347", "conclusion": "HFRWKV\u6210\u529f\u89e3\u51b3\u4e86RWKV\u5728GPU\u4e0a\u7684\u8ba1\u7b97\u6548\u7387\u95ee\u9898\uff0c\u901a\u8fc7FPGA\u4e13\u7528\u786c\u4ef6\u52a0\u901f\u5b9e\u73b0\u4e86\u663e\u8457\u7684\u6027\u80fd\u63d0\u5347\uff0c\u4e3aRNN\u67b6\u6784\u7684\u9ad8\u6548\u90e8\u7f72\u63d0\u4f9b\u4e86\u6709\u6548\u89e3\u51b3\u65b9\u6848"}}
