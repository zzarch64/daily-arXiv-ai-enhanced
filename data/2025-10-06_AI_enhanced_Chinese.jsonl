{"id": "2510.02675", "categories": ["cs.AR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.02675", "abs": "https://arxiv.org/abs/2510.02675", "authors": ["Shubham Negi", "Kaushik Roy"], "title": "HALO: Memory-Centric Heterogeneous Accelerator with 2.5D Integration for Low-Batch LLM Inference", "comment": null, "summary": "The rapid adoption of Large Language Models (LLMs) has driven a growing\ndemand for efficient inference, particularly in latency-sensitive applications\nsuch as chatbots and personalized assistants. Unlike traditional deep neural\nnetworks, LLM inference proceeds in two distinct phases: the prefill phase,\nwhich processes the full input sequence in parallel, and the decode phase,\nwhich generates tokens sequentially. These phases exhibit highly diverse\ncompute and memory requirements, which makes accelerator design particularly\nchallenging. Prior works have primarily been optimized for high-batch inference\nor evaluated only short input context lengths, leaving the low-batch and long\ncontext regime, which is critical for interactive applications, largely\nunderexplored.\n  We propose HALO, a heterogeneous memory centric accelerator designed for\nthese unique challenges of prefill and decode phases in low-batch LLM\ninference. HALO integrates HBM based Compute-in-DRAM (CiD) with an on-chip\nanalog Compute-in-Memory (CiM), co-packaged using 2.5D integration. To further\nimprove the hardware utilization, we introduce a phase-aware mapping strategy\nthat adapts to the distinct demands of the prefill and decode phases. Compute\nbound operations in the prefill phase are mapped to CiM to exploit its high\nthroughput matrix multiplication capability, while memory-bound operations in\nthe decode phase are executed on CiD to benefit from reduced data movement\nwithin DRAM. Additionally, we present an analysis of the performance tradeoffs\nof LLMs under two architectural extremes: a fully CiD and a fully on-chip\nanalog CiM design to highlight the need for a heterogeneous design. We evaluate\nHALO on LLaMA-2 7B and Qwen3 8B models. Our experimental results show that LLMs\nmapped to HALO achieve up to 18x geometric mean speedup over AttAcc, an\nattention-optimized mapping and 2.5x over CENT, a fully CiD based mapping.", "AI": {"tldr": "HALO\u662f\u4e00\u4e2a\u5f02\u6784\u5185\u5b58\u4e2d\u5fc3\u52a0\u901f\u5668\uff0c\u9488\u5bf9LLM\u63a8\u7406\u4e2d\u7684prefill\u548cdecode\u4e24\u4e2a\u9636\u6bb5\u7684\u4e0d\u540c\u8ba1\u7b97\u7279\u6027\u8fdb\u884c\u4f18\u5316\uff0c\u901a\u8fc7\u7ed3\u5408HBM CiD\u548c\u7247\u4e0aCiM\uff0c\u5728\u4f4e\u6279\u6b21\u957f\u4e0a\u4e0b\u6587\u573a\u666f\u4e0b\u5b9e\u73b0\u663e\u8457\u6027\u80fd\u63d0\u5347\u3002", "motivation": "LLM\u63a8\u7406\u5305\u542bprefill\u548cdecode\u4e24\u4e2a\u8ba1\u7b97\u7279\u6027\u5b8c\u5168\u4e0d\u540c\u7684\u9636\u6bb5\uff0c\u73b0\u6709\u5de5\u4f5c\u4e3b\u8981\u9488\u5bf9\u9ad8\u6279\u6b21\u63a8\u7406\u6216\u77ed\u4e0a\u4e0b\u6587\u4f18\u5316\uff0c\u800c\u4ea4\u4e92\u5f0f\u5e94\u7528\u9700\u8981\u7684\u4f4e\u6279\u6b21\u957f\u4e0a\u4e0b\u6587\u573a\u666f\u7814\u7a76\u4e0d\u8db3\u3002", "method": "\u63d0\u51faHALO\u5f02\u6784\u52a0\u901f\u5668\uff0c\u96c6\u6210HBM CiD\u548c\u7247\u4e0aCiM\uff0c\u91c7\u7528\u9636\u6bb5\u611f\u77e5\u6620\u5c04\u7b56\u7565\uff1aprefill\u9636\u6bb5\u8ba1\u7b97\u5bc6\u96c6\u578b\u64cd\u4f5c\u6620\u5c04\u5230CiM\uff0cdecode\u9636\u6bb5\u5185\u5b58\u5bc6\u96c6\u578b\u64cd\u4f5c\u6620\u5c04\u5230CiD\u3002", "result": "\u5728LLaMA-2 7B\u548cQwen3 8B\u6a21\u578b\u4e0a\uff0cHALO\u76f8\u6bd4AttAcc\u83b7\u5f9718\u500d\u51e0\u4f55\u5e73\u5747\u52a0\u901f\uff0c\u76f8\u6bd4\u5168CiD\u8bbe\u8ba1CENT\u83b7\u5f972.5\u500d\u52a0\u901f\u3002", "conclusion": "\u5f02\u6784\u5185\u5b58\u67b6\u6784\u80fd\u6709\u6548\u5e94\u5bf9LLM\u63a8\u7406\u4e2d\u4e0d\u540c\u9636\u6bb5\u7684\u591a\u6837\u5316\u8ba1\u7b97\u9700\u6c42\uff0c\u5728\u4f4e\u6279\u6b21\u957f\u4e0a\u4e0b\u6587\u573a\u666f\u4e0b\u5177\u6709\u663e\u8457\u4f18\u52bf\u3002"}}
{"id": "2510.02863", "categories": ["cs.AR", "cs.DS", "cs.NA", "math.NA", "quant-ph", "G.1.3; J.2; B.6.1"], "pdf": "https://arxiv.org/pdf/2510.02863", "abs": "https://arxiv.org/abs/2510.02863", "authors": ["D. A. Herrera-Mart\u00ed", "E. Guthmuller", "J. Fereyre"], "title": "A Hardware Accelerator for the Goemans-Williamson Algorithm", "comment": "Impact of Extended Precision Arithmetic in Interior Point Methods\n  using Conjugate Gradient. 10 pages. Hardware estimates", "summary": "The combinatorial problem Max-Cut has become a benchmark in the evaluation of\nlocal search heuristics for both quantum and classical optimisers. In contrast\nto local search, which only provides average-case performance guarantees, the\nconvex semidefinite relaxation of Max-Cut by Goemans and Williamson, provides\nworst-case guarantees and is therefore suited to both the construction of\nbenchmarks and in applications to performance-critic scenarios.\n  We show how extended floating point precision can be incorporated in\nalgebraic subroutines in convex optimisation, namely in indirect matrix\ninversion methods like Conjugate Gradient, which are used in Interior Point\nMethods in the case of very large problem sizes. Also, an estimate is provided\nof the expected acceleration of the time to solution for a hardware\narchitecture that runs natively on extended precision. Specifically, when using\nindirect matrix inversion methods like Conjugate Gradient, which have lower\ncomplexity than direct methods and are therefore used in very large problems,\nwe see that increasing the internal working precision reduces the time to\nsolution by a factor that increases with the system size.", "AI": {"tldr": "\u8be5\u8bba\u6587\u7814\u7a76\u4e86\u5728\u51f8\u4f18\u5316\u4e2d\u5f15\u5165\u6269\u5c55\u6d6e\u70b9\u7cbe\u5ea6\u6765\u52a0\u901f\u5927\u89c4\u6a21Max-Cut\u95ee\u9898\u7684\u6c42\u89e3\uff0c\u7279\u522b\u662f\u5728\u4f7f\u7528\u5171\u8f6d\u68af\u5ea6\u7b49\u95f4\u63a5\u77e9\u9635\u6c42\u9006\u65b9\u6cd5\u65f6\uff0c\u6269\u5c55\u7cbe\u5ea6\u80fd\u663e\u8457\u51cf\u5c11\u6c42\u89e3\u65f6\u95f4\u3002", "motivation": "Max-Cut\u95ee\u9898\u5df2\u6210\u4e3a\u91cf\u5b50\u4e0e\u7ecf\u5178\u4f18\u5316\u5668\u5c40\u90e8\u641c\u7d22\u542f\u53d1\u5f0f\u7b97\u6cd5\u7684\u57fa\u51c6\u6d4b\u8bd5\u3002\u4e0e\u4ec5\u63d0\u4f9b\u5e73\u5747\u6027\u80fd\u4fdd\u8bc1\u7684\u5c40\u90e8\u641c\u7d22\u4e0d\u540c\uff0cGoemans\u548cWilliamson\u7684\u51f8\u534a\u5b9a\u677e\u5f1b\u65b9\u6cd5\u63d0\u4f9b\u6700\u574f\u60c5\u51b5\u4fdd\u8bc1\uff0c\u9002\u7528\u4e8e\u57fa\u51c6\u6784\u5efa\u548c\u6027\u80fd\u5173\u952e\u573a\u666f\u3002", "method": "\u5728\u51f8\u4f18\u5316\u4e2d\u5f15\u5165\u6269\u5c55\u6d6e\u70b9\u7cbe\u5ea6\uff0c\u7279\u522b\u5e94\u7528\u4e8e\u5185\u70b9\u6cd5\u4e2d\u4f7f\u7528\u7684\u95f4\u63a5\u77e9\u9635\u6c42\u9006\u65b9\u6cd5\uff08\u5982\u5171\u8f6d\u68af\u5ea6\u6cd5\uff09\uff0c\u8fd9\u4e9b\u65b9\u6cd5\u5728\u8d85\u5927\u89c4\u6a21\u95ee\u9898\u4e2d\u6bd4\u76f4\u63a5\u65b9\u6cd5\u590d\u6742\u5ea6\u66f4\u4f4e\u3002", "result": "\u4f7f\u7528\u6269\u5c55\u7cbe\u5ea6\u65f6\uff0c\u5185\u90e8\u5de5\u4f5c\u7cbe\u5ea6\u7684\u63d0\u9ad8\u80fd\u51cf\u5c11\u6c42\u89e3\u65f6\u95f4\uff0c\u4e14\u52a0\u901f\u56e0\u5b50\u968f\u7cfb\u7edf\u89c4\u6a21\u589e\u5927\u800c\u589e\u52a0\u3002", "conclusion": "\u6269\u5c55\u6d6e\u70b9\u7cbe\u5ea6\u53ef\u6709\u6548\u52a0\u901f\u5927\u89c4\u6a21Max-Cut\u95ee\u9898\u7684\u51f8\u4f18\u5316\u6c42\u89e3\uff0c\u7279\u522b\u662f\u5728\u4f7f\u7528\u95f4\u63a5\u77e9\u9635\u6c42\u9006\u65b9\u6cd5\u65f6\uff0c\u8fd9\u79cd\u52a0\u901f\u6548\u679c\u968f\u95ee\u9898\u89c4\u6a21\u6269\u5927\u800c\u66f4\u52a0\u663e\u8457\u3002"}}
{"id": "2510.02990", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2510.02990", "abs": "https://arxiv.org/abs/2510.02990", "authors": ["Philippe Magalh\u00e3es", "Virginie Fresse", "Beno\u00eet Suffran", "Olivier Alata"], "title": "A Resource-Driven Approach for Implementing CNNs on FPGAs Using Adaptive IPs", "comment": "HiPEAC Workshop on Reconfigurable Computing (WRC), Jan 2025,\n  Barcelona, Spain", "summary": "The increasing demand for real-time, low-latency artificial intelligence\napplications has propelled the use of Field-Programmable Gate Arrays (FPGAs)\nfor Convolutional Neural Network (CNN) implementations. FPGAs offer\nreconfigurability, energy efficiency, and performance advantages over GPUs,\nmaking them suitable for edge devices and embedded systems. This work presents\na novel library of resource-efficient convolution IPs designed to automatically\nadapt to the available FPGA resources. Developed in VHDL, these IPs are\nparameterizable and utilize fixed-point arithmetic for optimal performance.\nFour IPs are introduced, each tailored to specific resource constraints,\noffering flexibility in DSP usage, logic consumption, and precision.\nExperimental results on a Zynq UltraScale+ FPGA highlight the trade-offs\nbetween performance and resource usage. The comparison with recent FPGA-based\nCNN acceleration techniques emphasizes the versatility and independence of this\napproach from specific FPGA architectures or technological advancements. Future\nwork will expand the library to include pooling and activation functions,\nenabling broader applicability and integration into CNN frameworks.", "AI": {"tldr": "\u5f00\u53d1\u4e86\u4e00\u4e2a\u8d44\u6e90\u9ad8\u6548\u7684\u5377\u79efIP\u5e93\uff0c\u80fd\u81ea\u52a8\u9002\u5e94FPGA\u53ef\u7528\u8d44\u6e90\uff0c\u4f7f\u7528VHDL\u5b9e\u73b0\uff0c\u652f\u6301\u53c2\u6570\u5316\u914d\u7f6e\u548c\u5b9a\u70b9\u7b97\u672f\uff0c\u5728Zynq UltraScale+ FPGA\u4e0a\u9a8c\u8bc1\u4e86\u6027\u80fd\u4e0e\u8d44\u6e90\u4f7f\u7528\u7684\u6743\u8861\u3002", "motivation": "\u968f\u7740\u5bf9\u5b9e\u65f6\u3001\u4f4e\u5ef6\u8fdfAI\u5e94\u7528\u9700\u6c42\u7684\u589e\u957f\uff0cFPGA\u56e0\u5176\u53ef\u91cd\u6784\u6027\u3001\u80fd\u6548\u548c\u6027\u80fd\u4f18\u52bf\uff0c\u5728CNN\u5b9e\u73b0\u4e2d\u6bd4GPU\u66f4\u9002\u5408\u8fb9\u7f18\u8bbe\u5907\u548c\u5d4c\u5165\u5f0f\u7cfb\u7edf\u3002", "method": "\u5f00\u53d1\u4e86\u56db\u4e2a\u53c2\u6570\u5316\u7684\u5377\u79efIP\u6838\uff0c\u4f7f\u7528VHDL\u5b9e\u73b0\u548c\u5b9a\u70b9\u7b97\u672f\uff0c\u6bcf\u4e2aIP\u9488\u5bf9\u7279\u5b9a\u8d44\u6e90\u7ea6\u675f\u8bbe\u8ba1\uff0c\u5728DSP\u4f7f\u7528\u3001\u903b\u8f91\u6d88\u8017\u548c\u7cbe\u5ea6\u65b9\u9762\u63d0\u4f9b\u7075\u6d3b\u6027\u3002", "result": "\u5728Zynq UltraScale+ FPGA\u4e0a\u7684\u5b9e\u9a8c\u7ed3\u679c\u8868\u660e\u4e86\u6027\u80fd\u4e0e\u8d44\u6e90\u4f7f\u7528\u4e4b\u95f4\u7684\u6743\u8861\uff0c\u4e0e\u73b0\u6709FPGA\u52a0\u901f\u6280\u672f\u76f8\u6bd4\uff0c\u8be5\u65b9\u6cd5\u5177\u6709\u66f4\u597d\u7684\u901a\u7528\u6027\u548c\u67b6\u6784\u72ec\u7acb\u6027\u3002", "conclusion": "\u8be5\u65b9\u6cd5\u5c55\u793a\u4e86\u8d44\u6e90\u9ad8\u6548\u5377\u79efIP\u7684\u53ef\u884c\u6027\uff0c\u672a\u6765\u5de5\u4f5c\u5c06\u6269\u5c55\u5e93\u4ee5\u5305\u542b\u6c60\u5316\u548c\u6fc0\u6d3b\u51fd\u6570\uff0c\u63d0\u5347\u5728CNN\u6846\u67b6\u4e2d\u7684\u9002\u7528\u6027\u548c\u96c6\u6210\u80fd\u529b\u3002"}}
