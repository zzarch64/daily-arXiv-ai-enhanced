<div id=toc></div>

# Table of Contents

- [cs.AR](#cs.AR) [Total: 4]


<div id='cs.AR'></div>

# cs.AR [[Back]](#toc)

### [1] [A System Architecture for Low Latency Multiprogramming Quantum Computing](https://arxiv.org/abs/2601.01158)
*Yilun Zhao,Yu Chen,Kaiyan Chang,He Li,Bing Li,Yinhe Han,Ying Wang*

Main category: cs.AR

TL;DR: FLAMENCO是一个保真度感知的多版本编译系统，通过离线编译和运行时动态区域选择，消除量子多程序计算中的在线编译开销，实现低延迟、高保真度的多程序执行。


<details>
  <summary>Details</summary>
Motivation: 随着量子系统规模扩大，多程序量子计算(MPQC)对提高设备利用率和吞吐量至关重要。然而，当前MPQC流水线依赖昂贵的在线编译来协同优化并发运行的程序，因为量子可执行文件是设备依赖的、跨量子比特区域不可移植的，并且对噪声和串扰高度敏感。这个在线步骤主导了运行时，阻碍了未来实际工作负载（如重复调用的量子神经网络服务）的低延迟部署。

Method: 1) 架构层面：将设备抽象为计算单元，大幅缩小区域分配的搜索空间；2) 编译时：为每个程序生成绑定到不同量子比特区域的多样化可执行版本，实现运行时动态区域选择；3) 运行时：采用简化的编排器，利用编译后保真度指标避免冲突和减轻串扰，实现无需在线协同优化的可靠协同执行。

Result: 与最先进的MPQC基线相比，FLAMENCO消除了在线编译开销，实现了超过5倍的运行时加速，提高了执行保真度，并在并发增加时保持高利用率。

Conclusion: FLAMENCO通过保真度感知的多版本编译系统，实现了独立离线编译和运行时低延迟、高保真度的多程序量子计算，解决了当前MPQC流水线中在线编译主导运行时的关键瓶颈。

Abstract: As quantum systems scale, Multiprogramming Quantum Computing (MPQC) becomes essential to improve device utilization and throughput. However, current MPQC pipelines rely on expensive online compilation to co-optimize concurrently running programs, because quantum executables are device-dependent, non-portable across qubit regions, and highly susceptible to noise and crosstalk. This online step dominates runtime and impedes low-latency deployments for practical, real-world workloads in the future, such as repeatedly invoked Quantum Neural Network (QNN) services.
  We present FLAMENCO, a fidelity-aware multi-version compilation system that enables independent offline compilation and low-latency, high-fidelity multiprogramming at runtime. At the architecture level, FLAMENCO abstracts devices into compute units to drastically shrink the search space of region allocation. At compile time, it generates diverse executable versions for each program -- each bound to a distinct qubit region -- allowing dynamic region selection at runtime and overcoming non-portability. At runtime, FLAMENCO employs a streamlined orchestrator that leverages post-compilation fidelity metrics to avoid conflicts and mitigate crosstalk, achieving reliable co-execution without online co-optimization. Comprehensive evaluations against state-of-the-art MPQC baselines show that FLAMENCO removes online compilation overhead, achieves over 5$\times$ runtime speedup, improves execution fidelity, and maintains high utilization as concurrency increases.

</details>


### [2] [CounterPoint: Using Hardware Event Counters to Refute and Refine Microarchitectural Assumptions (Extended Version)](https://arxiv.org/abs/2601.01265)
*Nick Lindsay,Caroline Trippel,Anurag Khandelwal,Abhishek Bhattacharjee*

Main category: cs.AR

TL;DR: CounterPoint是一个框架，通过测试用户指定的微架构模型与性能计数器数据的一致性，帮助专家解释模糊的硬件性能计数器数据，并发现未文档化的微架构行为。


<details>
  <summary>Details</summary>
Motivation: 硬件事件计数器虽然能揭示性能瓶颈和微架构行为，但由于其规范模糊、设计不透明以及多路复用噪声，使得计数器数据难以解释。需要一种方法来验证微架构模型与实测数据的一致性。

Method: 提出CounterPoint框架，使用μ路径决策图表达用户指定的微架构模型，测试这些模型与性能计数器数据的一致性。当出现不匹配时，通过多维计数器置信区域来减轻多路复用噪声，并定位可能解释这些不匹配的微架构特征。

Result: 将CounterPoint应用于Haswell内存管理单元作为案例研究，揭示了多个未文档化或文档不足的微架构行为，包括：加载存储队列侧的TLB预取器、合并页表遍历器、可中止的页表遍历等。

Conclusion: CounterPoint帮助专家将噪声硬件性能计数器测量结果与他们对微架构的心理模型相协调，在此过程中发现微妙、先前隐藏的硬件特征。

Abstract: Hardware event counters offer the potential to reveal not only performance bottlenecks but also detailed microarchitectural behavior. In practice, this promise is undermined by their vague specifications, opaque designs, and multiplexing noise, making event counter data hard to interpret.
  We introduce CounterPoint, a framework that tests user-specified microarchitectural models - expressed as $μ$path Decision Diagrams - for consistency with performance counter data. When mismatches occur, CounterPoint pinpoints plausible microarchitectural features that could explain them, using multi-dimensional counter confidence regions to mitigate multiplexing noise. We apply CounterPoint to the Haswell Memory Management Unit as a case study, shedding light on multiple undocumented and underdocumented microarchitectural behaviors. These include a load-store queue-side TLB prefetcher, merging page table walkers, abortable page table walks, and more.
  Overall, CounterPoint helps experts reconcile noisy hardware performance counter measurements with their mental model of the microarchitecture - uncovering subtle, previously hidden hardware features along the way.

</details>


### [3] [Ageing Monitoring for Commercial Microcontrollers Based on Timing Windows](https://arxiv.org/abs/2601.02053)
*Leandro Lanzieri,Jiri Kral,Goerschwin Fey,Holger Schlarb,Thomas C. Schmidt*

Main category: cs.AR

TL;DR: 提出一种基于软件自测试的微控制器硬件老化监测方法，通过可变长度时间窗口确定设备最大工作频率，可现场部署检测温度引起的性能退化


<details>
  <summary>Details</summary>
Motivation: 微控制器在嵌入式系统和可靠性应用中日益普及，硬件老化导致的故障可能产生严重影响。目前缺乏可部署的老化监测技术，普遍采用保护带方法防止退化引起的时序错误，但这种静态技术会限制性能并可能导致设备老化时突然失效。

Method: 采用基于软件的自测试方法设计微控制器硬件退化监测技术。该方法利用可变长度的时间窗口来确定设备的最大工作频率，可在现场部署。

Result: 在真实硬件上经验验证，该方法能一致检测到温度引起的最大工作频率退化，在温度升高60°C时，不同设备的频率退化最高可达13.79%。

Conclusion: 提出的软件自测试方法能有效监测微控制器硬件退化，解决了传统保护带方法的局限性，为嵌入式系统的可靠性提供了动态监测解决方案。

Abstract: Microcontrollers are increasingly present in embedded deployments and dependable applications, for which malfunctions due to hardware ageing can have severe impact. The lack of deployable techniques for ageing monitoring on these devices has spread the application of guard bands to prevent timing errors due to degradation. Applying this static technique can limit performance and lead to sudden failures as devices age. In this paper, we follow a software-based self-testing approach to design monitoring of hardware degradation for microcontrollers. Deployable in the field, our technique leverages timing windows of variable lengths to determine the maximum operational frequency of the devices. We empirically validate the method on real hardware and find that it consistently detects temperature-induced degradations in maximum operating frequency of up to 13.79 % across devices for 60 °C temperature increase.

</details>


### [4] [HFRWKV: A High-Performance Fully On-Chip Hardware Accelerator for RWKV](https://arxiv.org/abs/2601.02135)
*Liu Shijie,Zeng Zhenghao,Jiao Han,Huang Yihua*

Main category: cs.AR

TL;DR: HFRWKV：针对RWKV模型的FPGA硬件加速器，通过混合精度量化、可复用架构和全片上计算系统，显著提升吞吐量和能效


<details>
  <summary>Details</summary>
Motivation: RWKV作为现代RNN架构在处理长上下文时具有线性内存优势，但其顺序计算模式难以充分利用GPU并行性，且频繁的片外权重访问造成内存瓶颈

Method: 1）提出硬件友好的混合精度量化策略；2）针对指数和除法等复杂运算，采用可复用架构结合查找表或分段线性近似；3）采用全片上计算系统，集成并行矩阵向量处理阵列和高效流水线架构；4）通过计算重排序和分块双缓冲消除数据传输瓶颈

Result: 在Alveo U50和U280平台上实现，相比CPU实现63.48倍吞吐量提升和139.17倍能效提升；相比GPU实现32.33倍吞吐量提升和171.36倍能效提升

Conclusion: HFRWKV成功解决了RWKV在GPU上的计算效率问题，通过FPGA专用硬件加速实现了显著的性能提升，为RNN架构的高效部署提供了有效解决方案

Abstract: RWKV is a modern RNN architecture that approaches the performance of Transformers, with the advantage of processing long contexts at a linear memory cost. However, its sequential computation pattern struggles to efficiently leverage GPU parallelism, which leads to low compute resource utilization. Furthermore, frequent off-chip weight accesses create a memory bottleneck. To address these challenges, we propose HFRWKV, an FPGA-based hardware accelerator specifically designed for RWKV. Within the matrix operation module, we propose a novel hardware-friendly hybrid-precision quantization strategy, which enhances performance while maintaining acceptable accuracy. For the complex operations including exponentiation and division, we introduce a method featuring reusable architectures combined with lookup tables or piecewise linear approximation, which is algorithmically refined to effectively balance precision and hardware resource consumption. Based on this foundation, we adopt a fully on-chip computing system integrating parallel matrix-vector processing array and an efficient pipeline architecture. Through computation reordering and chunked double buffering, it effectively eliminates data transfer bottlenecks and improves overall throughput. We implement HFRWKV on the Alveo U50 and U280 platform. Experimental results show that compared to a CPU, a throughput improvement of 63.48$\times$ and an energy efficiency improvement of 139.17$\times$. Compared to GPUs, achieves a throughput improvement of 32.33$\times$ and an energy efficiency improvement of 171.36$\times$.

</details>
